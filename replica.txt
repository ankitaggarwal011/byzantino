# Assumption: The slot number is global and not per client.
slot_number = 0 # initialize slot number

get_slot_number():
    slot_number = slot_number + 1
    return slot_number

Replica:
    # Assumption: One shuttle supports one operation per each client.
    # Assumption: Only one configuration is active at a given time.
    
    # A replica can have either of three states at a given time: ACTIVE, PENDING, or IMMUTABLE
    # Initial configuration has all replicas with active state
    # All other configuration replicas are in pending state
    # A replica goes to immutable state in case of a potential failure (upon wedge request from Olympus)
    # H => Sign the data with the given private key
    # check_H => Check signature with the corresponding public key
    # hash => Calculate SHA 256 hash of the given data
    # s => slot number allotted to the requested operation
    # o => requested operation by the client
    # head => head replica of the current configuration
    # tail => tail replica of the current configuration
    # result_cache = {} # key-value store to cache result against particular request id
    # checkpoint_proof => list of hashed running states of each replica along the chain
    # timer => creates a timer for the current replica

    replica_id # id of the current replica
    state = {ACTIVE | PENDING | IMMUTABLE}
    running_state # current state of the replica in the given configuration
    history = [] # history of the current replica, contains the list of order proofs for all operations since the last checkpoint

    send(event message, receiver, ...):
        # sends the event message to the receiver with the given variable arguments
        # It is assumed that the programming language and compiler exposes an implementation of a similar method for 
        # inter-process communication among different nodes

    start_timer():
        return timer()

    cancel_timer(current_timer):
        current_timer.cancel()

    init_request(request_id, o):
        if replica_id == head:
            s = get_slot_number()
            request_shuttle = [] # initialize request shuttle
            order_command(s, o, request_shuttle)
            current_timer = start_timer() # start timer to check for timeout

    init_checkpointing():
        if slot_number / 100 is integer: # for every 100 slots
            clear_cache()
            checkpoint_proof = [hash(running_state)]
            checkpoint = slot_number
            send("checkpointing", replica_id + 1, checkpoint, checkpoint_proof)
    
    apply_operation(o): 
        result = o(running_state) # running_state is modified to new running_state
        return result
    
    is_valid_proof(s, o, order_proof):
        for each <s_p, o_p, r_p> in order_proof: # s_p, o_p, and r_p is the slot number, operation and replica id of each previous replica in the
                                                 # configuration respectively
        if s == s_p and o != o_p:
            return False
        return True

    order_command(s, o, request_shuttle):
        for each previous replica r_p:
            if not check_H(request_shuttle.order_proof of r_p, public key of r_p):
                send("reconfiguration", olympus) # notify olympus if any of the previous replica is incorrectly signed
                return
        if not is_valid_proof(s, o, request_shuttle.order_proof):
            send("reconfiguration", olympus) # notify olympus if the operation described against a specific slot number is not unique in the 
                                           # order-proofs of previous replicas
            return
        request_shuttle.order_proof = request_shuttle.order_proof + H([s, o], replica_private_key)
        history = history + [request_shuttle.order_proof]
        result = apply_operation(o)
        request_shuttle.result_proof = request_shuttle.result_proof + H([o, hash(result)], replica_private_key)
        return request_shuttle

    receive(statement, sender_id, ...):
        if check_H(statement, public key of sender_id): # validate identity with signature
            if statement == "request from client" or statement == "request from peer":
                send_result_to_client(request_id_args) # request_id_args => request_id_args passed from the variable arguments
            else if statement == "wedge request":
                state = IMMUTABLE # change state to IMMUTABLE
                send("wedged statement", olympus, history, checkpoint_proof, hash(running_state))
            else if statement == "catch up":
                catch_up(set_of_operations_to_apply)
            else if statement == "get_running_state":
                send("running state", olympus, running_state)
            else if statement == "result shuttle":
                receive_result_shuttle_from_successor(request_id, result_shuttle_args) # result_shuttle_args => result_shuttle passed from the 
                                                                                       # variable arguments
            else if statement == "request shuttle":
                receive_request_shuttle_from_predessor(s, o, request_shuttle_args)     # request_shuttle_args => request_shuttle passed from the
                                                                                       # variable arguments
            else if statement == "checkpointing":
                if replica_id < tail:
                    checkpoint_proof = checkpoint_proof_args + [hash(running_state)] # checkpoint_proof_args => checkpoint_proof passed from the 
                                                                                     # variable arguments
                    send("checkpointing", replica_id + 1, checkpoint, checkpoint_proof)
                else:
                    send("checkpoint proof", replica_id - 1, checkpoint)
                    history = history[checkpoint:] # truncating history before the checkpoint
            else if statement == "checkpoint proof":
                if replica_id < tail:
                    send("checkpoint proof", replica_id - 1, checkpoint)
                    history = history[checkpoint:] # truncating history before the checkpoint

    forward_result_shuttle_to_predessor(request_id, result_shuttle):
        send("result shuttle", replica_id - 1, request_id, result_shuttle)

    receive_result_shuttle_from_successor(request_id, request_shuttle):
        cancel_timer(current_timer)
        result_cache[request_id] = (result_shuttle.r, result_shuttle.result_proof) # result_shuttle.r => result provided by predecessor

    forward_request_shuttle_to_successor(request_shuttle):
        send("request shuttle", replica_id + 1, s, o, request_shuttle.request_id, request_shuttle)

    receive_request_shuttle_from_predessor(s, o, request_shuttle):
        request_shuttle = order_command(s, o, request_shuttle)
        return request_shuttle

    check_cache(request_id):
        if request_id in result_cache:
            return True
        return False

    clear_cache():
        if slot_number / 100 is an integer:
            result_cache = {} # clear cache for every 100 slots, other cache management techniques can also
                              # be applied to enhance implementation performance

    send_result_to_client(request_id):
        if check_cache(request_id):
            send("result to client", client, result_cache[request_id])
        else:
            if replica_id > head:
                send("redirect to head", head, request_id) # redirect request to head if not found in result cache
                start_timer() # start timer to check for timeout
            else:
                init_request(request_id) # start the request from scratch

    catch_up(set_of_operations_to_apply):
        for each operation o_c in set_of_operations_to_apply:
            result = o_c(running_state) # running_state will be modified to the new_running_state
        send("caught up", olympus)

    check_timeout():
        if current_timer.has_ended(): # if the timer has finished, send reconfiguration request to the olympus
            send("reconfiguration", olympus)


Result_Shuttle:
    # Convention: o => operation to be performed as a part of client request
    # Assumption: result of applying operation o to each replica is the same

    r # result after applying operation to the running state of the tail
    completedResultProofs = [] # list of tuple signatures for the result at each replica
                               #: Sign(<o, hash(result)> using private key of replica_id)



Request_Shuttle:
    # Convention: s => monotonically increasing slot number for client request, assigned by head
    # Convention: o => operation to be performed as a part of client request
    # Assumption: we don't need to keep a separate slot member variable, replicas
    # handling request shuttle can automatically infer it from the orderProofs

    requestId: # Unique Identifier for client request
    orderProofs = []  # list of tuple signatures:  Sign(<s,o, replica_id> using private key of replica_id)
    resultProofs = [] # list of tuple signatures for the result at each replica that has processed shuttle
                      # : Sign(<o, hash(result)> using private key of replica_id)


