from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError

# import for deserialization of message objects
from ast import literal_eval
replica_module = import_da('replica')
from time import time,sleep
from config import *
import read_config

# The Olympus process. It creates replicas, and co-ordinates the passing of public keys to and from clients and replicas
# It also handles system reconfiguration, which is not implemented yet
class Olympus(process):
    # Olympus setup method. It receives config information, and passes it to applicable replicas
    def setup(name, num_replicas, num_failures, all_replica_conf_failures, head_timeout, replica_timeout):
        self.state = 'NORMAL'
        self.num_failures = num_failures
        self.replicas = dict()
        self.replica_private_keys = list()
        self.replica_public_keys = list()
        self.head = None
        self.tail = None
        self.running_state_validated = 0 # used during reconfiguration
        self.wedged_responses = list()
        self.quorum_start_index = 0
        self.quorum = list()
        self.longest_history = list()
        self.chosen_running_state = None
        self.running_states_received = 0
        self.ignore_further_caught_up_messages = 0
        # generate own keys
        self.private_key = SigningKey.generate()
        self.public_key = self.private_key.verify_key.encode(encoder=HexEncoder)
        self.configuration_number = 0  # default configuration for phase 2
        self.client_keys = {}  # client keys will be obtained later in message passing
        # get all replica failures in current configuration
        all_replica_failures = all_replica_conf_failures.get(self.configuration_number, {})
        for i in range(num_replicas):
            # get all failure scenarios in current replica
            replica_failures = all_replica_failures.get(i, {})
            running_state = dict()
            if i == 0:
                # create head replica
                replica = new(replica_module.Replica, args=(i, 'Head', running_state, replica_failures, head_timeout, public_key))
                self.head = replica
            elif i == num_replicas - 1:
                # create tail replica
                replica = new(replica_module.Replica, args=(i, 'Tail', running_state, replica_failures, replica_timeout, public_key))
                self.tail = replica
            else:
                # create other replica
                replica = new(replica_module.Replica, args=(i, 'Replica ' + str(i), running_state, replica_failures, replica_timeout, public_key))
            self.replicas[i] = replica
            replica_name = 'Replica ' + str(i)
            output_wrapper('Olympus created replica process: {}'.format(replica_name))
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder=HexEncoder)
            output_wrapper(
                'Olympus created keys for replica process: {}. Public key: {}'.format(replica_name, str(verify_key)))
            self.replica_private_keys.append(signing_key)
            self.replica_public_keys.append(verify_key)

    # ACK message from client/replica
    def receive(msg=('ACK', sender)):
        output_wrapper('ACK from ' + str(sender) + '.')

    # Get configuration message handler from client in which client passes its own reference and key
    # Pass required information to all replicas and reply to client with current configuration details (replicas, head)
    def receive(msg=('Get_configuration', client, client_name, client_id, client_public_key)):
        if state != 'NORMAL':
            return
        client_keys[client_id] = VerifyKey(client_public_key, encoder=HexEncoder)
        send(('Configuration', replicas, head), to=client)
        send(('Keys', replica_public_keys, public_key), to=client)
        for i, r in replicas.items():
            send(('Client_keys', client_id, client_public_key), to=r)
        output_wrapper('Received public key: {} from client: {}'.format(str(client_public_key), str(client_name)))
        output_wrapper('Configuration sent to ' + str(client_name) + '.')


    def begin_reconfiguration():
        if state == 'RECONFIGURATION':
            output_wrapper('System is already in reconfiguration. Ignoring new reconfiguration command.')
            return
        state = 'RECONFIGURATION'
        output_wrapper('Changing states of replicas from old configuration to IMMUTABLE.')
        for i, r in replicas.items():
            send(('Immutable'), to=r)
        output_wrapper('Sending wedge requests: checking replicas: ' + str(replicas))
        for i, r in replicas.items():
            output_wrapper('Sending wedge requests to replica: ' + str(i))
            send(('wedge_request'), to=r)

    def select_quorum():
        output_wrapper('Selecting a new quorum.')
        quorum = list()
        longest_history = list()
        wedged_responses.sort(reverse=True, key=lambda x: len(x[0]))
        while quorum_start_index < len(wedged_responses) and len(quorum) < num_failures + 1:
            longest_history = wedged_responses[quorum_start_index][0]
            for w_resp in wedged_responses[quorum_start_index:]:
                if w_resp[0] == longest_history[:len(w_resp[0])]: # checking if a history is prefix of longest history
                    quorum.append(w_resp)
                if len(quorum) == num_failures + 1:
                    break
            quorum_start_index += 1
        if len(quorum) == 0:
            output_wrapper('No quorum formed. System can\'t handle more than ' + str(num_failures) + '.')
            return
        output_wrapper('Quorum is selected.')
        ignore_further_caught_up_messages = 0 # reset
        running_states_received = 0
        chosen_running_state = None
        for i in quorum:
            gap = longest_history[len(i[0]):]
            send(('catch_up', gap), to=replicas[i[1]])
        if await(some(received(('caught_up', None, None)), has=(running_states_received == len(quorum)))):
            pass
        elif timeout(2): # wait for 2s and select new quorum if some running states in Q are missing
            if running_states_received < len(quorum):
                output_wrapper('Number of running states received are less than the size of quorum.')
                select_quorum()

    # get all wedged messages, make a sorted list out of all sorted valid histories [<s, o>, ...]
    # choose first (longest history), and check if there other t consistent replicas, if yes, create quorum, save the index
    # if this quorum fails, choose new quorum from the saved index
    def receive(msg=('wedge', hist, replica_id)):
        output_wrapper('Wedge message from Replica ' + str(replica_id))
        # check signature of replica #todo
        for order_p in hist:
            if not validate_order_proof(order_p):
                return
        wedged_responses.append([sorted([o_p[:-1] for o_p in hist], key=lambda x: x[0]), replica_id])
        if len(wedged_responses) == (num_failures + 1):
            output_wrapper('Received ' + str(len(wedged_responses)) + ' wedged responses.')
            select_quorum()

    def validate_order_proof(order_p):
        slot_number, operation, configuration, order_stmt = order_p
        for stmt in order_stmt:
            if stmt[0] != slot_number or stmt[1] != operation or stmt[2] != configuration:
                return False
        return True

    def receive(msg=('caught_up', hash_running_state, replica_id)):
        output_wrapper('Caught up message received from Replica ' + str(replica_id))
        if ignore_further_caught_up_messages: return
        if not (chosen_running_state == None or hash_running_state == chosen_running_state):
            output_wrapper('Chosen quorum is not valid as the hash of all running states don\'t match.')
            ignore_further_caught_up_messages = 1
            select_quorum()
            return
        running_states_received += 1
        chosen_running_state = hash_running_state
        if running_states_received == len(quorum):
            get_running_state_from_quorum()

    def get_running_state_from_quorum():
        output_wrapper('Getting the running state from the quorum.')
        for each_member in quorum:
            if not running_state_validated:
                send(('get_running_state'), to=replicas[each_member[1]])
                await(received(('response_get_running_state', None, None)))

    # Reconfiguration request. This may come from a client or a replica. Client sends proof of misbehavior, replica doesn't.
    # replica piggybacks configuration onto proof_of_misbehavior variable
    def receive(msg=('Reconfiguration', sender, proof_of_misbehavior)):
        output_wrapper('Reconfiguration request received from ' + str(sender) + '.')
        if (isinstance(proof_of_misbehavior, int) and proof_of_misbehavior == configuration_number) or (isinstance(proof_of_misbehavior, list) and validate_proof_of_misbehavior(proof_of_misbehavior)):
            output_wrapper('Reconfiguration request sent by ' + str(sender) + ' is valid. Starting reconfiguration.')
            begin_reconfiguration() # Reconfigure and send new configuration to the replicas
        else:
            output_wrapper('Proof of misbehavior sent by ' + str(sender) + ' is not valid. If it is sent by replica, its configuration doesn\'t match and if its sent by client, proof of misbehavior is invalid.')

    def receive(msg=('response_get_running_state', replica_id, replica_running_state)):
        output_wrapper('Response to get_running_state from Replica ' + str(replica_id) + ' received by Olympus.')
        output_wrapper('Validating the running_state with the quorum.')
        if calculate_hash(replica_running_state) == chosen_running_state:
            running_state_validated = 1
            init_new_configuration(replica_running_state)

    def validate_proof_of_misbehavior(proof_of_misbehavior):
        result, result_proof = proof_of_misbehavior
        if len(result_proof) < num_failures + 1:
            return True
        majority = 0
        hash = calculate_hash(result)
        for i in result_proof:
            if hash == i[1]:
                majority += 1
        if majority < 2 * num_failures + 1:
            return True
        return False

    # calculate the sha256 hash of value
    def calculate_hash(val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        elif isinstance(val, dict):
            return sha256(str.encode(str(val)), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    # Encrypt data with own private key and send
    def sign_and_send(data, to_):
        data = list(data)
        data[-1] = private_key.sign(str(data[-1]).encode('utf-8'))
        send(tuple(data), to=to_)

    # Verify and unpack data with someone else's public key
    def verify_data_with_key(data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def init_new_configuration(new_running_state):
        output_wrapper('Shutting down replicas from old configuration.')
        for i, r in replicas.items():
            send(('Shutdown'), to=r)
        configuration_number += 1 # new configuration
        # resetting replicas
        replicas = dict()
        replica_private_keys = list()
        replica_public_keys = list()
        head = None
        tail = None
        # get all replica failures in current configuration
        all_replica_failures = all_replica_conf_failures.get(configuration_number, {})
        for i in range(num_replicas):
            # get all failure scenarios in current replica
            replica_failures = all_replica_failures.get(i, {})
            if i == 0:
                # create head replica
                replica = new(replica_module.Replica, args=(i, 'Head', new_running_state, replica_failures, head_timeout, public_key))
                head = replica
            elif i == num_replicas - 1:
                # create tail replica
                replica = new(replica_module.Replica, args=(i, 'Tail', new_running_state, replica_failures, replica_timeout, public_key))
                tail = replica
            else:
                # create other replica
                replica = new(replica_module.Replica, args=(i, 'Replica ' + str(i), new_running_state, replica_failures, replica_timeout, public_key))
            replicas[i] = replica
            replica_name = 'Replica ' + str(i)
            output_wrapper('Olympus created replica process: {}'.format(replica_name))
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder=HexEncoder)
            output_wrapper(
                'Olympus created keys for replica process: {}. Public key: {}'.format(replica_name, str(verify_key)))
            replica_private_keys.append(signing_key)
            replica_public_keys.append(verify_key)
        
        # reset variables used during reconfiguration
        running_state_validated = 0
        quorum = list()
        wedged_responses = list()
        quorum_start_index = 0
        longest_history = list()
        chosen_running_state = None
        running_states_received = 0
        ignore_further_caught_up_messages = 0

        for i, r in replicas.items():
            start(r)
            sign_and_send(('Configuration', self, replicas, head, tail, [replica_public_keys, configuration_number]), r)
            send(('Key', replica_private_keys[i]), to=r)
        
        state = 'NORMAL'
        output_wrapper('Reconfiguration is successful.')
        output_wrapper('New replicas: ' + str(replicas))

    # Run loop. Won't exit till Shutdown is received (never).
    # Start replicas and send them initial configuration message
    def run():
        for i, r in replicas.items():
            start(r)
            sign_and_send(('Configuration', self, replicas, head, tail, [replica_public_keys, configuration_number]), r)
            send(('Key', replica_private_keys[i]), to=r)

        await(received(('ACK', None)))
        await(received(('Shutdown')))

    # Utility method for logging, prepends process name and time to each log statement
    def output_wrapper(log):
        output('[{}][TS: {}]'.format(name, str(time())), log)
