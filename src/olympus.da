from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError

# import for deserialization of message objects
from ast import literal_eval
replica_module = import_da('replica')
from time import time
from config import *
import read_config

# The Olympus process. It creates replicas, and co-ordinates the passing of public keys to and from clients and replicas
# It also handles system reconfiguration, which is not implemented yet
class Olympus(process):
    # Olympus setup method. It receives config information, and passes it to applicable replicas
    def setup(name, num_replicas, num_failures, all_replica_conf_failures, head_timeout, replica_timeout):
        self.state = 'NORMAL'
        self.num_failures = num_failures
        self.replicas = dict()
        self.replica_private_keys = list()
        self.replica_public_keys = list()
        self.head = None
        self.tail = None
        # generate own keys
        self.private_key = SigningKey.generate()
        self.public_key = self.private_key.verify_key.encode(encoder=HexEncoder)
        self.configuration_number = 0  # default configuration for phase 2
        self.client_keys = {}  # client keys will be obtained later in message passing
        # get all replica failures in current configuration
        all_replica_failures = all_replica_conf_failures.get(self.configuration_number, {})
        for i in range(num_replicas):
            # get all failure scenarios in current replica
            replica_failures = all_replica_failures.get(i, {})
            if i == 0:
                # create head replica
                replica = new(replica_module.Replica, args=(i, 'Head', replica_failures, head_timeout, public_key), at='Node2')
                self.head = replica
            elif i == num_replicas - 1:
                # create tail replica
                replica = new(replica_module.Replica, args=(i, 'Tail', replica_failures, replica_timeout, public_key), at='Node2')
                self.tail = replica
            else:
                # create other replica
                replica = new(replica_module.Replica, args=(i, 'Replica ' + str(i), replica_failures, replica_timeout, public_key), at='Node2')
            self.replicas[i] = replica
            replica_name = 'Replica ' + str(i)
            output_wrapper('Olympus created replica process: {}'.format(replica_name))
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder=HexEncoder)
            output_wrapper(
                'Olympus created keys for replica process: {}. Public key: {}'.format(replica_name, str(verify_key)))
            self.replica_private_keys.append(signing_key)
            self.replica_public_keys.append(verify_key)

    # ACK message from client/replica
    def receive(msg=('ACK', sender)):
        output_wrapper('ACK from ' + str(sender) + '.')

    # Get configuration message handler from client in which client passes its own reference and key
    # Pass required information to all replicas and reply to client with current configuration details (replicas, head)
    def receive(msg=('Get_configuration', client, client_name, client_id, client_public_key)):
        client_keys[client_id] = VerifyKey(client_public_key, encoder=HexEncoder)
        send(('Configuration', replicas, head), to=client)
        send(('Keys', replica_public_keys, public_key), to=client)
        for i, r in replicas.items():
            send(('Client_keys', client_id, client_public_key), to=r)
        output_wrapper('Received public key: {} from client: {}'.format(str(client_public_key), str(client_name)))
        output_wrapper('Configuration sent to ' + str(client_name) + '.')


    def begin_reconfiguration():
        if state == 'RECONFIGURATION':
            output_wrapper('System already in reconfiguration. ignoring new reconfiguration command')
            return
        state = 'RECONFIGURATION'
        output_wrapper('Sending wedge requests to replicas: ' + str(len(replicas)))
        output_wrapper('Sending wedge requests: checking replicas:  ' + str(replicas))
        for i, r in replicas.items():
            output_wrapper('Sending wedge requests to replica: ' + str(i))
            send(('wedge_request', self), to= r)

        quorum_size = 0
        quorum_range = []
        send_ts = time()
        num_wedge_responses = 0
        if await(some(received(('wedge', hist, checkpoint_proof, hashed_running_state, replica, ts)), has=(ts >= send_ts))):
            while True:
            # blocking wait for atleast one wedge message
                output_wrapper('Waiting for wedge statements')
            # TODO add check for greater than last check
                --wedge
                curr_ts = time()
                if curr_ts - send_ts >= 0.05:
                    output_wrapper("Timed out waiting for wedge statements. ")
                    break
                if await(some(received(('wedge', hist, checkpoint_proof, hashed_running_state, replica, ts)), has=(ts >= send_ts))):
                    output_wrapper('Received some wedged statements')
                    wss = listof((hist, checkpoint_proof, hashed_running_state, replica, ts), ts >= send_ts, received(('wedge', hist, checkpoint_proof, hashed_running_state, replica, ts)))
                    if (len(wss) < num_failures + 1):
                        continue
                    output_wrapper("We have quorum length")
                    len_wss = len(wss);
                    output_wrapper("Len_Wss is " + str(len_wss))
                    qs = num_failures + 1;
                    output_wrapper("QS is " + str(qs))
                    for i in range(0, len_wss -qs + 1):
                        indices_range = range(i, i + qs);
                        histories = list()
                        output_wrapper("Indices range is " + str(indices_range))
                        for j in indices_range:
                            histories.append(wss[j][0])
                        res = is_valid_quorum(histories)
                        if res[0] == True:
                            # found a valid quorum, break
                            quorum_replicas = []
                            for j in indices_range:
                                quorum_replicas.append(wss[j][3])
                            on_successful_quorum(histories, quorum_replicas)


        elif timeout(5):
            output_wrapper('Timed out while waiting for wedged statements')
            #await(some(received(('wedge', _hist, _check_proof, _hash_running_state)))):
            #await(received(('wedge', history, checkpoint_proof, hash_running_state)))
            #add replica to quorum <histories, checkpoint_proofs, hashed_running_states>
            #quorum_size += 1
            #quorum_range.append(replica)
            # now we will make a quorum with a size of T + 1, and attempt to find a valid history
            #quorum_result_pair = is_valid_quorum(histories, quorum_range)
            #if quorum_size > T + 1 and is_valid_quorum(...):
                #break
            #for each replica in quorum_range:
                #send('get_running_state') to replica[i]
                #rs = wait_for_message('running_state', rs, timeout)
                #if (hash(rs) == quorum_result_pair.second):   # this means that the running state hash computed earlier while validating quorum,
                                                              # matches the one sent by the currently queried replica. This means we can now reconfigure.
                #init_replicas(rs, lh)
                #return
        state = 'NORMAL'
        return

    # function that returns a tuple of boolean validity of quorum and hash of result
    def is_valid_quorum(histories, indices):
        output_wrapper("In is_valid_quorum")
        output_wrapper("Histories: "  + str(histories))
        output_wrapper("Indices: "  + str(indices))
        for i in range(0, len(histories)):                      # proceed for each pair <i,j> in indices, nested loop
            for j in range(0, len(histories)):              # for each tuple <si,oi> in history[i]
                for k in range(0, len(histories[i])):
                    output_wrapper("i: " + str(i) + " j: " + str(j) + " k: " + str(k))
                    matches = list(set([v[1] for i, v in enumerate(histories[j]) if v[0] == histories[i][k][0]]))  # find a tuple <sj, oj> in history[j] such that s = si, o = anything
                    output_wrapper("Matches: " +str(matches))
                    if (len(matches) > 1) or (matches[0] != histories[i][k][1]):                            # if oi and oj don't match, the history is invalid due to a possible failure
                        return (False, None)
        # the quorum is valid up to this point. Now we ask each replica to catch up.
        output_wrapper("Quorum is valid!!")
        return (True, None)
        #lh = max(histories)
        #for i in indices:
        #   send('catch_up', lh - histories[i]) to replica[i]
        #hashed_running_states = wait_aggregate(size(indices), on_message_received('caught_up', hashed_running_state))
        #unique_running_states = unique(hashed_running_states)
        #if  size(unique_running_state) > 1:
        #    # all hashes must be the same for a valid quorum
        #    return <false, null>
        #return <true, unique_running_states[0]>


    def on_successful_quorum(histories, quorum_replicas):
        max_hist_len = -1;
        max_hist = []
        for i in range(0, len(histories)):
            if len(histories[i]) > max_hist_len:
                max_hist_len = len(histories[i])
                max_hist = histories[i]
        send_ts = time()
        for i, r in enumerate(quorum_replicas):
            gap = list(set(max_hist) - set(histories[i]))
            send(('catch_up', gap), to=r)

        #TODO change this logic to also check for pub keys for all replicas
        if await( len((replica, ts), ts>= send_ts, received(('catch_up', replica, ts))) > len(histories)):
            output_wrapper("Received replies from all replicas")
        elif timeout(3):
            output_wrapper("Timed out while waiting for caught up messages");

        #--wait for caught_up messages
    def receive(msg=('wedge', _hist, _check_proof, _hash_running_state, replica)):
        output_wrapper('Wedge msg handler from: ' + str(replica))

    def receive(msg=('caught_up', replica, timestamp)):
        output_wrapper('Caught up msg handler from: ' + str(replica))

    # Reconfiguration request. This may come from a client or a replica. Client sends proof of misbehavior, replica doesn't.
    # This is not implemented in Phase 2. Will be done in Phase 3.
    def receive(msg=('Reconfiguration', sender, proof_of_misbehavior)):
        output_wrapper('Reconfiguration request received from ' + str(sender) + '.')
        begin_reconfiguration()
        # Reconfigure and send new configuration to client and replicas

    # Encrypt data with own private key and send
    def sign_and_send(data, to_):
        data = list(data)
        data[-1] = private_key.sign(str(data[-1]).encode('utf-8'))
        send(tuple(data), to=to_)

    # Verify and unpack data with someone else's public key
    def verify_data_with_key(data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    # Run loop. Won't exit till Shutdown is received (never).
    # Start replicas and send them initial configuration message
    def run():
        for i, r in replicas.items():
            start(r)
            sign_and_send(('Configuration', self, replicas, head, tail, [replica_public_keys, configuration_number]), r)
            send(('Key', replica_private_keys[i]), to=r)

        await(received(('ACK', None)))
        await(received(('Shutdown')))

    # Utility method for logging, prepends process name and time to each log statement
    def output_wrapper(log):
        output('[{}][TS: {}]'.format(name, str(time())), log)
