from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError

# import for deserialization of message objects
from ast import literal_eval
replica_module = import_da('replica')
from time import time
from config import *
import read_config

# The Olympus process. It creates replicas, and co-ordinates the passing of public keys to and from clients and replicas
# It also handles system reconfiguration, which is not implemented yet
class Olympus(process):
    # Olympus setup method. It receives config information, and passes it to applicable replicas
    def setup(name, num_replicas, num_failures, all_replica_conf_failures, head_timeout, replica_timeout):
        self.state = 'NORMAL'
        self.num_failures = num_failures
        self.replicas = dict()
        self.replica_private_keys = list()
        self.replica_public_keys = list()
        self.head = None
        self.tail = None
        self.running_state_validated = 0 # used during reconfiguration
        self.quorum = list()
        self.quorum_replicas = list()
        self.longest_history = list()
        self.chosen_running_state = None
        self.running_states_received = 0
        self.ignore_further_caught_up_messages = 0
        # generate own keys
        self.private_key = SigningKey.generate()
        self.public_key = self.private_key.verify_key.encode(encoder=HexEncoder)
        self.configuration_number = 0  # default configuration for phase 2
        self.client_keys = {}  # client keys will be obtained later in message passing
        # get all replica failures in current configuration
        all_replica_failures = all_replica_conf_failures.get(self.configuration_number, {})
        for i in range(num_replicas):
            # get all failure scenarios in current replica
            replica_failures = all_replica_failures.get(i, {})
            running_state = dict()
            if i == 0:
                # create head replica
                replica = new(replica_module.Replica, args=(i, 'Head', running_state, replica_failures, head_timeout, public_key))
                self.head = replica
            elif i == num_replicas - 1:
                # create tail replica
                replica = new(replica_module.Replica, args=(i, 'Tail', running_state, replica_failures, replica_timeout, public_key))
                self.tail = replica
            else:
                # create other replica
                replica = new(replica_module.Replica, args=(i, 'Replica ' + str(i), running_state, replica_failures, replica_timeout, public_key))
            self.replicas[i] = replica
            replica_name = 'Replica ' + str(i)
            output_wrapper('Olympus created replica process: {}'.format(replica_name))
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder=HexEncoder)
            output_wrapper(
                'Olympus created keys for replica process: {}. Public key: {}'.format(replica_name, str(verify_key)))
            self.replica_private_keys.append(signing_key)
            self.replica_public_keys.append(verify_key)

    # ACK message from client/replica
    def receive(msg=('ACK', sender)):
        output_wrapper('ACK from ' + str(sender) + '.')

    # Get configuration message handler from client in which client passes its own reference and key
    # Pass required information to all replicas and reply to client with current configuration details (replicas, head)
    def receive(msg=('Get_configuration', client, client_name, client_id, client_public_key)):
        if state != 'NORMAL':
            return
        client_keys[client_id] = VerifyKey(client_public_key, encoder=HexEncoder)
        send(('Configuration', replicas, head), to=client)
        send(('Keys', replica_public_keys, public_key), to=client)
        for i, r in replicas.items():
            send(('Client_keys', client_id, client_public_key), to=r)
        output_wrapper('Received public key: {} from client: {}'.format(str(client_public_key), str(client_name)))
        output_wrapper('Configuration sent to ' + str(client_name) + '.')


    def begin_reconfiguration():
        if state == 'RECONFIGURATION':
            output_wrapper('System is already in reconfiguration. Ignoring new reconfiguration command.')
            return
        state = 'RECONFIGURATION'
        output('Changing states of replicas from old configuration to IMMUTABLE and spawning new replicas in the new configuration.')
        for i, r in replicas.items():
            send(('Immutable'), to=r)
        select_quorum()

    def select_quorum():
        output_wrapper('Sending wedge requests: checking replicas: ' + str(replicas))
        for i, r in replicas.items():
            output_wrapper('Sending wedge requests to replica: ' + str(i))
            send(('wedge_request'), to=r)

    def on_successful_quorum():
        for i, r in enumerate(quorum_replicas):
            gap = [j for j in longest_history if j not in quorum[i]]
            send(('catch_up', gap), to=replicas[r])

    def receive(msg=('wedge', hist, replica_id)):
        output_wrapper('Wedge message from Replica ' + str(replica_id))
        if len(quorum) < num_failures + 1:
            # check signature of replica #todo
            for order_p in hist:
                if not validate_order_proof(order_p):
                    return
            for i in range(len(hist)):
                if i < len(longest_history):
                    order_p = hist[i]
                    order_p_lh = longest_history[i]
                    if not (order_p[0] == order_p_lh[0] and order_p[1] == order_p_lh[1] and order_p[2] == order_p_lh[2]):
                        return
            quorum.append([o_p[:-1] for o_p in hist])
            quorum_replicas.append(replica_id)
            if len(hist) > len(longest_history):
                longest_history = [o_p[:-1] for o_p in hist]
            if len(quorum) == num_failures + 1:
                on_successful_quorum()

    def validate_order_proof(order_p):
        slot_number, operation, configuration, order_stmt = order_p
        for stmt in order_stmt:
            if stmt[0] != slot_number or stmt[1] != operation or stmt[2] != configuration:
                return False
        return True

    def receive(msg=('caught_up', hash_running_state, replica_id)):
        output_wrapper('Caught up message received from Replica ' + str(replica_id))
        if ignore_further_caught_up_messages: return
        if not (chosen_running_state == None or hash_running_state == chosen_running_state):
            output_wrapper('Chosen quorum is not valid as the hash of all running states don\'t match.')
            output_wrapper('Selecting a new quorum.')
            ignore_further_caught_up_messages = 1
            select_quorum()
            return
        running_states_received += 1
        chosen_running_state = hash_running_state
        if running_states_received == len(quorum):
            get_running_state_from_quorum()


    def get_running_state_from_quorum():
        output_wrapper('Getting the running state from the quorum.')
        for i, r in enumerate(quorum_replicas):
            if not running_state_validated:
                send(('get_running_state'), to=replicas[r])
                await(received(('response_get_running_state', None, None)))

    # Reconfiguration request. This may come from a client or a replica. Client sends proof of misbehavior, replica doesn't.
    # replica piggybacks configuration onto proof_of_misbehavior variable
    def receive(msg=('Reconfiguration', sender, proof_of_misbehavior)):
        output_wrapper('Reconfiguration request received from ' + str(sender) + '.')
        if (isinstance(proof_of_misbehavior, int) and proof_of_misbehavior == configuration_number) or (isinstance(proof_of_misbehavior, list) and validate_proof_of_misbehavior(proof_of_misbehavior)):
            output_wrapper('Reconfiguration request sent by ' + str(sender) + ' is valid. Starting reconfiguration.')
            begin_reconfiguration() # Reconfigure and send new configuration to the replicas
        else:
            output_wrapper('Proof of misbehavior sent by ' + str(sender) + ' is not valid. If it is sent by replica, its configuration doesn\'t match and if its sent by client, proof of misbehavior is invalid.')

    def receive(msg=('response_get_running_state', replica_id, replica_running_state)):
        output_wrapper('Response to get_running_state from Replica ' + str(replica_id) + ' received by Olympus.')
        output_wrapper('Validating the running_state with the quorum.')
        if calculate_hash(replica_running_state) == chosen_running_state:
            running_state_validated = 1
            init_new_configuration(replica_running_state)

    def validate_proof_of_misbehavior(proof_of_misbehavior):
        result, result_proof = proof_of_misbehavior
        if len(result_proof) < num_failures + 1:
            return True
        majority = 0
        hash = calculate_hash(result)
        for i in result_proof:
            if hash == i[1]:
                majority += 1
        if majority < 2 * num_failures + 1:
            return True
        return False

    # calculate the sha256 hash of value
    def calculate_hash(val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        elif isinstance(val, dict):
            return sha256(str.encode(str(val)), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    # Encrypt data with own private key and send
    def sign_and_send(data, to_):
        data = list(data)
        data[-1] = private_key.sign(str(data[-1]).encode('utf-8'))
        send(tuple(data), to=to_)

    # Verify and unpack data with someone else's public key
    def verify_data_with_key(data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def init_new_configuration(new_running_state):
        output('Shutting down replicas from old configuration.')
        for i, r in replicas.items():
            send(('Shutdown'), to=r)
        configuration_number += 1 # new configuration
        # resetting replicas
        replicas = dict()
        replica_private_keys = list()
        replica_public_keys = list()
        head = None
        tail = None
        # get all replica failures in current configuration
        all_replica_failures = all_replica_conf_failures.get(configuration_number, {})
        for i in range(num_replicas):
            # get all failure scenarios in current replica
            replica_failures = all_replica_failures.get(i, {})
            if i == 0:
                # create head replica
                replica = new(replica_module.Replica, args=(i, 'Head', new_running_state, replica_failures, head_timeout, public_key))
                head = replica
            elif i == num_replicas - 1:
                # create tail replica
                replica = new(replica_module.Replica, args=(i, 'Tail', new_running_state, replica_failures, replica_timeout, public_key))
                tail = replica
            else:
                # create other replica
                replica = new(replica_module.Replica, args=(i, 'Replica ' + str(i), new_running_state, replica_failures, replica_timeout, public_key))
            replicas[i] = replica
            replica_name = 'Replica ' + str(i)
            output_wrapper('Olympus created replica process: {}'.format(replica_name))
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder=HexEncoder)
            output_wrapper(
                'Olympus created keys for replica process: {}. Public key: {}'.format(replica_name, str(verify_key)))
            replica_private_keys.append(signing_key)
            replica_public_keys.append(verify_key)
        
        # reset variables used during reconfiguration
        running_state_validated = 0
        quorum = list()
        quorum_replicas = list()
        longest_history = list()
        chosen_running_state = None
        running_states_received = 0
        ignore_further_caught_up_messages = 0

        for i, r in replicas.items():
            start(r)
            sign_and_send(('Configuration', self, replicas, head, tail, [replica_public_keys, configuration_number]), r)
            send(('Key', replica_private_keys[i]), to=r)
        
        state = 'NORMAL'
        output_wrapper('Reconfiguration is successful.')

    # Run loop. Won't exit till Shutdown is received (never).
    # Start replicas and send them initial configuration message
    def run():
        for i, r in replicas.items():
            start(r)
            sign_and_send(('Configuration', self, replicas, head, tail, [replica_public_keys, configuration_number]), r)
            send(('Key', replica_private_keys[i]), to=r)

        await(received(('ACK', None)))
        await(received(('Shutdown')))

    # Utility method for logging, prepends process name and time to each log statement
    def output_wrapper(log):
        output('[{}][TS: {}]'.format(name, str(time())), log)
