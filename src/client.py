# -*- generated by 1.0.9 -*-
import da
PatternExpr_276 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.FreePattern('replicas_dict_'), da.pat.FreePattern('head_')])
PatternExpr_285 = da.pat.FreePattern('olympus')
PatternExpr_333 = da.pat.TuplePattern([da.pat.ConstantPattern('Keys'), da.pat.FreePattern('replica_public_keys_'), da.pat.FreePattern('olympus_public_key_')])
PatternExpr_342 = da.pat.FreePattern('olympus')
PatternExpr_378 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Operation_result'), da.pat.FreePattern('request_id'), da.pat.FreePattern('result_shuttle')])
PatternExpr_559 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern562_'), da.pat.BoundPattern('_BoundPattern563_')])
PatternExpr_613 = da.pat.BoundPattern('_BoundPattern619_')
PatternExpr_685 = da.pat.ConstantPattern('Shutdown')
PatternExpr_566 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern576_'), da.pat.BoundPattern('_BoundPattern577_')])])
PatternExpr_621 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern628_')])
PatternExpr_689 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Shutdown')])
_config_object = {}
from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError
from ast import literal_eval
from time import time
from config import *
import read_config

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_3 = []
        self._ClientReceivedEvent_4 = []
        self._ClientReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_276, sources=[PatternExpr_285], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_275]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_333, sources=[PatternExpr_342], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_332]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_378, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_377]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_559, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_613, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_685, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, client_id, olympus, request_id, client_timeout, operations, num_failures, **rest_1029):
        super().setup(client_id=client_id, olympus=olympus, request_id=request_id, client_timeout=client_timeout, operations=operations, num_failures=num_failures, **rest_1029)
        self._state.client_id = client_id
        self._state.olympus = olympus
        self._state.request_id = request_id
        self._state.client_timeout = client_timeout
        self._state.operations = operations
        self._state.num_failures = num_failures
        self._state.name = ('Client ' + str(self._state.client_id))
        self._state.replicas = None
        self._state.replicas_dict = None
        self._state.head = None
        self._state.replica_public_keys = None
        self._state.olympus_public_key = None
        self._state.private_key = SigningKey.generate()
        self._state.public_key = self._state.private_key.verify_key.encode(encoder=HexEncoder)
        self._state.client_running_state = dict()
        self._state.client_running_state_sync = dict()

    def run(self):
        if (self._state.replicas is None):
            self.send(('Get_configuration', self._id, self._state.name, self._state.client_id, self._state.public_key), to=self._state.olympus)
            super()._label('_st_label_556', block=False)
            _st_label_556 = 0
            while (_st_label_556 == 0):
                _st_label_556 += 1
                if PatternExpr_566.match_iter(self._ClientReceivedEvent_3, _BoundPattern576_=self._state.replicas_dict, _BoundPattern577_=self._state.head, SELF_ID=self._id):
                    _st_label_556 += 1
                else:
                    super()._label('_st_label_556', block=True)
                    _st_label_556 -= 1
        for op in self._state.operations:
            self.update_client_running_state(self._state.client_running_state, op[0], op[1])
            retry = 0
            while True:
                self.send_request(op[0], op[1], retry)
                super()._label('_st_label_610', block=False)
                _st_label_610 = 0
                self._timer_start()
                while (_st_label_610 == 0):
                    _st_label_610 += 1
                    if PatternExpr_621.match_iter(self._ClientReceivedEvent_4, _BoundPattern628_=('Operation_result_' + str(self._state.request_id)), SELF_ID=self._id):
                        break
                        _st_label_610 += 1
                    elif self._timer_expired:
                        self.output_wrapper('Timeout: Retrying request id: {}, sending to all replicas'.format(str(self._state.request_id)))
                        retry = 1
                        _st_label_610 += 1
                    else:
                        super()._label('_st_label_610', block=True, timeout=self._state.client_timeout)
                        _st_label_610 -= 1
                else:
                    if (_st_label_610 != 2):
                        continue
                if (_st_label_610 != 2):
                    break
        self.output_wrapper((('Local running state of client after the given set of operations: ' + str(self._state.client_running_state)) + '.'))
        self.output_wrapper((('Running state of client at the server (assuming no conflicting keys from other clients) after the given set of operations: ' + str(self._state.client_running_state_sync)) + '.'))
        if are_dicts_equal(self._state.client_running_state, self._state.client_running_state_sync):
            self.output_wrapper('\n\nTest case passed! Actual and expected running states match.\n\n')
        else:
            self.output_wrapper("\n\nTest case failed! Actual and expected running states don't match\n\n")
        super()._label('_st_label_682', block=False)
        _st_label_682 = 0
        while (_st_label_682 == 0):
            _st_label_682 += 1
            if PatternExpr_689.match_iter(self._ClientReceivedEvent_5, SELF_ID=self._id):
                _st_label_682 += 1
            else:
                super()._label('_st_label_682', block=True)
                _st_label_682 -= 1

    def sign_and_send(self, data, to_):
        data = list(data)
        data[(- 1)] = self._state.private_key.sign(str(data[(- 1)]).encode('utf-8'))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def update_client_running_state(self, running_state, type, args):
        if (type == 'put'):
            if (len(args) > 1):
                running_state[args[0]] = args[1]
            return 'OK'
        elif (type == 'get'):
            if (len(args) > 0):
                if (args[0] in running_state):
                    return running_state[args[0]]
                else:
                    return ''
        elif (type == 'slice'):
            if (len(args) > 1):
                (lower, upper) = map(int, args[1].split(':'))
                if ((args[0] in running_state) and (lower >= 0) and (upper <= len(running_state[args[0]]))):
                    running_state[args[0]] = running_state[args[0]][lower:upper]
                    return running_state[args[0]]
                else:
                    return 'fail'
        elif (type == 'append'):
            if (len(args) > 1):
                if (args[0] in running_state):
                    running_state[args[0]] = (running_state[args[0]] + args[1])
                    return 'OK'
                else:
                    return 'fail'

    def send_request(self, type, args, retry):
        args = self._state.private_key.sign(str(args).encode('utf-8'))
        if retry:
            for r in self._state.replicas:
                self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args), to=r)
        else:
            self._state.request_id += 1
            self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args), to=self._state.head)

    def validate_result(self, result, result_proof):
        if (len(result_proof) < (self._state.num_failures + 1)):
            self.output_wrapper('Number of result proofs received are less than the majority (failures + 1).')
            return (False, True)
        majority = 0
        hash = self.calculate_hash(result)
        for i in result_proof:
            if (hash == i[1]):
                majority += 1
        self.output_wrapper('Number of correct result proofs received :{}, required majority: {}'.format(majority, (self._state.num_failures + 1)))
        if (majority < (self._state.num_failures + 1)):
            return (False, True)
        elif (majority < ((2 * self._state.num_failures) + 1)):
            return (True, True)
        return (True, False)

    def calculate_hash(self, val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    def output_wrapper(self, log):
        self.output('[{}][TS: {}]'.format(self._state.name, str(time())), log)

    def _Client_handler_275(self, replicas_dict_, head_, olympus):
        self._state.replicas_dict = replicas_dict_
        self._state.replicas = list()
        for (i, replica) in replicas_dict_.items():
            self._state.replicas.append(replica)
        self._state.head = head_
        self.output_wrapper((self._state.name + ' is configured.'))
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_275._labels = None
    _Client_handler_275._notlabels = None

    def _Client_handler_332(self, replica_public_keys_, olympus_public_key_, olympus):
        self._state.replica_public_keys = [VerifyKey(key, encoder=HexEncoder) for key in replica_public_keys_]
        self._state.olympus_public_key = VerifyKey(olympus_public_key_, encoder=HexEncoder)
        self.output_wrapper('Received the public keys of replicas from Olympus')
        self.output_wrapper('Received the public key of Olympus.')
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_332._labels = None
    _Client_handler_332._notlabels = None

    def _Client_handler_377(self, sender_id, request_id, result_shuttle):
        result_shuttle = self.verify_data_with_key(result_shuttle, self._state.replica_public_keys[sender_id])
        if (result_shuttle == None):
            self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed.'))
            return
        (result, result_proof) = result_shuttle
        (is_result__valid, is_reconfiguration_required) = self.validate_result(result, result_proof)
        if is_result__valid:
            if ((not (result == 'fail')) or (not (result == ''))):
                self.update_client_running_state(self._state.client_running_state_sync, result_proof[0][0][0], result_proof[0][0][1])
            self.output_wrapper('Valid result: {} received for request id: {}'.format(str(result), str(request_id)))
        if is_reconfiguration_required:
            self.output_wrapper('Misbehaviour detected in request id: {}! Sending reconfiguration request to Olympus'.format(request_id))
            self.send(('Reconfiguration', self._state.name, result_shuttle), to=self._state.olympus)
    _Client_handler_377._labels = None
    _Client_handler_377._notlabels = None

def are_dicts_equal(d1, d2):
    return ((len(d1) == len(d2)) and all(((k in d2) for k in d1)))
