# -*- generated by 1.0.10 -*-
import da
PatternExpr_290 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.FreePattern('replicas_dict_'), da.pat.FreePattern('head_')])
PatternExpr_299 = da.pat.FreePattern('olympus')
PatternExpr_345 = da.pat.TuplePattern([da.pat.ConstantPattern('Keys'), da.pat.FreePattern('replica_public_keys_'), da.pat.FreePattern('olympus_public_key_')])
PatternExpr_354 = da.pat.FreePattern('olympus')
PatternExpr_390 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Operation_result_error'), da.pat.FreePattern('request_id')])
PatternExpr_417 = da.pat.TuplePattern([da.pat.ConstantPattern('running_state'), da.pat.FreePattern('running_state')])
PatternExpr_429 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Operation_result'), da.pat.FreePattern('request_id'), da.pat.FreePattern('result_shuttle')])
PatternExpr_540 = da.pat.TuplePattern([da.pat.ConstantPattern('Operation_result_reconfig'), da.pat.FreePattern('result_s')])
PatternExpr_547 = da.pat.FreePattern('olympus')
PatternExpr_711 = da.pat.BoundPattern('_BoundPattern723_')
PatternExpr_760 = da.pat.BoundPattern('_BoundPattern766_')
PatternExpr_782 = da.pat.BoundPattern('_BoundPattern788_')
PatternExpr_841 = da.pat.BoundPattern('_BoundPattern847_')
PatternExpr_892 = da.pat.ConstantPattern('Shutdown')
PatternExpr_725 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern732_')])
PatternExpr_768 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern775_')])
PatternExpr_790 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern797_')])
PatternExpr_849 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern856_')])
PatternExpr_896 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Shutdown')])
_config_object = {'channel': {'reliable', 'fifo'}}
from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError
from json import dumps
from ast import literal_eval
from time import time, sleep
from config import *
import read_config

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_6 = []
        self._ClientReceivedEvent_7 = []
        self._ClientReceivedEvent_8 = []
        self._ClientReceivedEvent_9 = []
        self._ClientReceivedEvent_10 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_290, sources=[PatternExpr_299], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_289]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_345, sources=[PatternExpr_354], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_344]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_390, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_389]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_417, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_416]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_429, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_428]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_540, sources=[PatternExpr_547], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_539]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_6', PatternExpr_711, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_7', PatternExpr_760, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_8', PatternExpr_782, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_9', PatternExpr_841, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_10', PatternExpr_892, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, client_id, olympus, request_id, client_timeout, operations, num_failures, **rest_1308):
        super().setup(client_id=client_id, olympus=olympus, request_id=request_id, client_timeout=client_timeout, operations=operations, num_failures=num_failures, **rest_1308)
        self._state.client_id = client_id
        self._state.olympus = olympus
        self._state.request_id = request_id
        self._state.client_timeout = client_timeout
        self._state.operations = operations
        self._state.num_failures = num_failures
        self._state.name = ('Client ' + str(self._state.client_id))
        self._state.replicas = None
        self._state.replicas_dict = None
        self._state.head = None
        self._state.replica_public_keys = None
        self._state.olympus_public_key = None
        self._state.private_key = SigningKey.generate()
        self._state.public_key = self._state.private_key.verify_key.encode(encoder=HexEncoder)
        self._state.client_running_state = dict()
        self._state.client_running_state_sync = dict()
        self._state.requests_sent = 0

    def run(self):
        N = 2
        for (op_n, op) in enumerate(self._state.operations):
            self.update_client_running_state(self._state.client_running_state, op[0], op[1])
            retry = 0
            while True:
                if (((self._state.requests_sent % N) == 0) or (op_n == (len(self._state.operations) - 1))):
                    self.output_wrapper('Checking with Olympus for new configuration.')
                    self.send(('Get_configuration', self._id, self._state.name, self._state.client_id, self._state.public_key, self._state.requests_sent), to=self._state.olympus)
                    super()._label('_st_label_708', block=False)
                    _st_label_708 = 0
                    while (_st_label_708 == 0):
                        _st_label_708 += 1
                        if PatternExpr_725.match_iter(self._ClientReceivedEvent_6, _BoundPattern732_=((('Configuration_' + str(self._state.client_id)) + '_') + str(self._state.requests_sent)), SELF_ID=self._id):
                            _st_label_708 += 1
                        else:
                            super()._label('_st_label_708', block=True)
                            _st_label_708 -= 1
                    else:
                        if (_st_label_708 != 2):
                            continue
                    if (_st_label_708 != 2):
                        break
                self.send_request(op[0], op[1], retry)
                self._state.requests_sent += 1
                super()._label('_st_label_756', block=False)
                _st_label_756 = 0
                self._timer_start()
                while (_st_label_756 == 0):
                    _st_label_756 += 1
                    if (PatternExpr_768.match_iter(self._ClientReceivedEvent_7, _BoundPattern775_=('Operation_result_' + str(self._state.request_id)), SELF_ID=self._id) or PatternExpr_790.match_iter(self._ClientReceivedEvent_8, _BoundPattern797_=('Operation_result_reconfig_' + str(self._state.request_id)), SELF_ID=self._id)):
                        break
                        _st_label_756 += 1
                    elif self._timer_expired:
                        self.output_wrapper('Timeout: Retrying request id: {}, sending to all replicas'.format(str(self._state.request_id)))
                        retry = 1
                        _st_label_756 += 1
                    else:
                        super()._label('_st_label_756', block=True, timeout=self._state.client_timeout)
                        _st_label_756 -= 1
                else:
                    if (_st_label_756 != 2):
                        continue
                if (_st_label_756 != 2):
                    break
                sleep(0.1)
        self.output_wrapper((('Local running state of client after the given set of operations: ' + str(self._state.client_running_state)) + '.'))
        self.send(('get_running_state', self._id, self._state.requests_sent), to=self._state.head)
        super()._label('_st_label_838', block=False)
        _st_label_838 = 0
        while (_st_label_838 == 0):
            _st_label_838 += 1
            if PatternExpr_849.match_iter(self._ClientReceivedEvent_9, _BoundPattern856_=('running_state_' + str(self._state.requests_sent)), SELF_ID=self._id):
                _st_label_838 += 1
            else:
                super()._label('_st_label_838', block=True)
                _st_label_838 -= 1
        self.output_wrapper((('\n\nRunning state at the server after the given set of operations: ' + str(dumps(self._state.client_running_state_sync, sort_keys=True))) + '.\n\n'))
        if are_dicts_valid(self._state.client_running_state, self._state.client_running_state_sync):
            self.output_wrapper('Assuming no conflicting keys from other clients:\n\nTest case passed! Actual and expected running states match.\n\n')
        else:
            self.output_wrapper("Assuming no conflicting keys from other clients:\n\nTest case failed! Actual and expected running states don't match\n\n")
        super()._label('_st_label_889', block=False)
        _st_label_889 = 0
        while (_st_label_889 == 0):
            _st_label_889 += 1
            if PatternExpr_896.match_iter(self._ClientReceivedEvent_10, SELF_ID=self._id):
                _st_label_889 += 1
            else:
                super()._label('_st_label_889', block=True)
                _st_label_889 -= 1

    def sign_and_send(self, data, to_):
        data = list(data)
        data[(- 1)] = self._state.private_key.sign(str(data[(- 1)]).encode('utf-8'))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def update_client_running_state(self, running_state, type, args):
        if (type == 'put'):
            if (len(args) > 1):
                running_state[args[0]] = args[1]
            return 'OK'
        elif (type == 'get'):
            if (len(args) > 0):
                if (args[0] in running_state):
                    return running_state[args[0]]
                else:
                    return ''
        elif (type == 'slice'):
            if (len(args) > 1):
                (lower, upper) = map(int, args[1].split(':'))
                if ((args[0] in running_state) and (lower >= 0) and (upper <= len(running_state[args[0]]))):
                    running_state[args[0]] = running_state[args[0]][lower:upper]
                    return running_state[args[0]]
                else:
                    return 'fail'
        elif (type == 'append'):
            if (len(args) > 1):
                if (args[0] in running_state):
                    running_state[args[0]] = (running_state[args[0]] + args[1])
                    return 'OK'
                else:
                    return 'fail'

    def send_request(self, type, args, retry):
        op_args = list(args)[:]
        args = self._state.private_key.sign(str(args).encode('utf-8'))
        if retry:
            self.output_wrapper((((((((str(self._state.name) + ' is sending ') + str(type)) + ' request with args ') + str(op_args)) + ' for request id ') + str(self._state.request_id)) + ' in retry mode.'))
            for r in self._state.replicas:
                self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args, None), to=r)
        else:
            self._state.request_id += 1
            self.output_wrapper((((((((str(self._state.name) + ' is sending ') + str(type)) + ' request with args ') + str(op_args)) + ' for request id ') + str(self._state.request_id)) + '.'))
            self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args, None), to=self._state.head)

    def validate_result(self, result, result_proof):
        if (len(result_proof) < (self._state.num_failures + 1)):
            self.output_wrapper('Number of result proofs received are less than the majority (failures + 1).')
            return (False, True)
        majority = 0
        hash = self.calculate_hash(result)
        for i in result_proof:
            if (hash == i[1]):
                majority += 1
        self.output_wrapper('Number of correct result proofs received :{}, required majority: {}'.format(majority, (self._state.num_failures + 1)))
        if (majority < (self._state.num_failures + 1)):
            return (False, True)
        elif (majority < ((2 * self._state.num_failures) + 1)):
            return (True, True)
        return (True, False)

    def calculate_hash(self, val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        elif isinstance(val, dict):
            return sha256(str.encode(dumps(val, sort_keys=True)), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    def output_wrapper(self, log):
        self.output('[TS: {}][{}]'.format(str(time()), self._state.name), log)

    def _Client_handler_289(self, replicas_dict_, head_, olympus):
        self._state.replicas_dict = replicas_dict_
        self._state.replicas = list()
        for (i, replica) in replicas_dict_.items():
            self._state.replicas.append(replica)
        self._state.head = head_
        self.output_wrapper(((self._state.name + ' is configured with ') + str(self._state.head)))
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_289._labels = None
    _Client_handler_289._notlabels = None

    def _Client_handler_344(self, replica_public_keys_, olympus_public_key_, olympus):
        self._state.replica_public_keys = [VerifyKey(key, encoder=HexEncoder) for key in replica_public_keys_]
        self._state.olympus_public_key = VerifyKey(olympus_public_key_, encoder=HexEncoder)
        self.output_wrapper('Received the public keys of replicas from Olympus')
        self.output_wrapper('Received the public key of Olympus.')
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_344._labels = None
    _Client_handler_344._notlabels = None

    def _Client_handler_389(self, sender_id, request_id):
        self.output_wrapper((((('Result during reconfiguration: Received ERROR message for request id ' + str(request_id)) + ' from Replica ') + str(sender_id)) + '.'))
    _Client_handler_389._labels = None
    _Client_handler_389._notlabels = None

    def _Client_handler_416(self, running_state):
        self._state.client_running_state_sync = running_state
    _Client_handler_416._labels = None
    _Client_handler_416._notlabels = None

    def _Client_handler_428(self, sender_id, request_id, result_shuttle):
        result_shuttle = self.verify_data_with_key(result_shuttle, self._state.replica_public_keys[sender_id])
        if (result_shuttle == None):
            self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed.'))
            return
        (result, result_proof) = result_shuttle
        (is_result__valid, is_reconfiguration_required) = self.validate_result(result, result_proof)
        if is_result__valid:
            if ((not (result == 'fail')) or (not (result == ''))):
                self.update_client_running_state(self._state.client_running_state_sync, result_proof[0][0][0], result_proof[0][0][1])
            self.output_wrapper('Result: {} received for request id: {}'.format(str(result), str(request_id)))
        if is_reconfiguration_required:
            self.output_wrapper('Misbehaviour detected in request id: {}! Sending reconfiguration request to Olympus'.format(request_id))
            self.send(('Reconfiguration', self._state.name, result_shuttle), to=self._state.olympus)
    _Client_handler_428._labels = None
    _Client_handler_428._notlabels = None

    def _Client_handler_539(self, result_s, olympus):
        (result, result_stmt, request_id_) = result_s
        if ((not (result == 'fail')) or (not (result == ''))):
            self.update_client_running_state(self._state.client_running_state_sync, result_stmt[0][0], result_stmt[0][1])
        self.output_wrapper('Result from Olympus: {} received from Olympus during reconfiguration for request id: {}'.format(str(result), str(request_id_)))
    _Client_handler_539._labels = None
    _Client_handler_539._notlabels = None

def are_dicts_valid(d1, d2):
    return all(((k in d2) for k in d1))
