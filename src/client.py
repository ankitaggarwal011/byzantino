# -*- generated by 1.0.9 -*-
import da
PatternExpr_288 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.FreePattern('replicas_dict_'), da.pat.FreePattern('head_')])
PatternExpr_297 = da.pat.FreePattern('olympus')
PatternExpr_343 = da.pat.TuplePattern([da.pat.ConstantPattern('Keys'), da.pat.FreePattern('replica_public_keys_'), da.pat.FreePattern('olympus_public_key_')])
PatternExpr_352 = da.pat.FreePattern('olympus')
PatternExpr_388 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Operation_result'), da.pat.FreePattern('request_id'), da.pat.FreePattern('result_shuttle')])
PatternExpr_420 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern423_'), da.pat.BoundPattern('_BoundPattern424_')])
PatternExpr_611 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern614_'), da.pat.BoundPattern('_BoundPattern615_')])
PatternExpr_672 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern675_'), da.pat.BoundPattern('_BoundPattern676_')])
PatternExpr_708 = da.pat.BoundPattern('_BoundPattern714_')
PatternExpr_783 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern786_'), da.pat.BoundPattern('_BoundPattern787_')])
PatternExpr_806 = da.pat.ConstantPattern('Shutdown')
PatternExpr_618 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern628_'), da.pat.BoundPattern('_BoundPattern629_')])])
PatternExpr_679 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern689_'), da.pat.BoundPattern('_BoundPattern690_')])])
PatternExpr_716 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern723_')])
PatternExpr_790 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern800_'), da.pat.BoundPattern('_BoundPattern801_')])])
PatternExpr_810 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Shutdown')])
PatternExpr_427 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern437_'), da.pat.BoundPattern('_BoundPattern438_')])])
_config_object = {}
from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError
from ast import literal_eval
from time import time
from config import *
import read_config

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_3 = []
        self._ClientReceivedEvent_4 = []
        self._ClientReceivedEvent_5 = []
        self._ClientReceivedEvent_6 = []
        self._ClientReceivedEvent_7 = []
        self._ClientReceivedEvent_8 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_288, sources=[PatternExpr_297], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_287]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_343, sources=[PatternExpr_352], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_342]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_388, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_387]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_420, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_611, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_672, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_6', PatternExpr_708, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_7', PatternExpr_783, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_8', PatternExpr_806, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, client_id, olympus, request_id, client_timeout, operations, num_failures, **rest_1193):
        super().setup(client_id=client_id, olympus=olympus, request_id=request_id, client_timeout=client_timeout, operations=operations, num_failures=num_failures, **rest_1193)
        self._state.client_id = client_id
        self._state.olympus = olympus
        self._state.request_id = request_id
        self._state.client_timeout = client_timeout
        self._state.operations = operations
        self._state.num_failures = num_failures
        self._state.name = ('Client ' + str(self._state.client_id))
        self._state.replicas = None
        self._state.replicas_dict = None
        self._state.head = None
        self._state.replica_public_keys = None
        self._state.olympus_public_key = None
        self._state.private_key = SigningKey.generate()
        self._state.public_key = self._state.private_key.verify_key.encode(encoder=HexEncoder)
        self._state.client_running_state = dict()
        self._state.client_running_state_sync = dict()
        self._state.num_retries = 0
        self._state.max_retries = 1

    def run(self):
        if (self._state.replicas is None):
            self.send(('Get_configuration', self._id, self._state.name, self._state.client_id, self._state.public_key), to=self._state.olympus)
            super()._label('_st_label_608', block=False)
            _st_label_608 = 0
            while (_st_label_608 == 0):
                _st_label_608 += 1
                if PatternExpr_618.match_iter(self._ClientReceivedEvent_4, _BoundPattern628_=self._state.replicas_dict, _BoundPattern629_=self._state.head, SELF_ID=self._id):
                    _st_label_608 += 1
                else:
                    super()._label('_st_label_608', block=True)
                    _st_label_608 -= 1
        for op in self._state.operations:
            self.update_client_running_state(self._state.client_running_state, op[0], op[1])
            retry = 0
            while True:
                if (self._state.num_retries > self._state.max_retries):
                    self.output_wrapper('Number of retries exceeded max retries, trying to get latest configuration from olympus')
                    self.send(('Get_configuration', self._id, self._state.name, self._state.client_id, self._state.public_key), to=self._state.olympus)
                    super()._label('_st_label_669', block=False)
                    _st_label_669 = 0
                    while (_st_label_669 == 0):
                        _st_label_669 += 1
                        if PatternExpr_679.match_iter(self._ClientReceivedEvent_5, _BoundPattern689_=self._state.replicas_dict, _BoundPattern690_=self._state.head, SELF_ID=self._id):
                            _st_label_669 += 1
                        else:
                            super()._label('_st_label_669', block=True)
                            _st_label_669 -= 1
                    else:
                        if (_st_label_669 != 2):
                            continue
                    if (_st_label_669 != 2):
                        break
                    self._state.num_retries = 0
                self.send_request(op[0], op[1], retry)
                super()._label('_st_label_705', block=False)
                _st_label_705 = 0
                self._timer_start()
                while (_st_label_705 == 0):
                    _st_label_705 += 1
                    if PatternExpr_716.match_iter(self._ClientReceivedEvent_6, _BoundPattern723_=('Operation_result_' + str(self._state.request_id)), SELF_ID=self._id):
                        break
                        _st_label_705 += 1
                    elif self._timer_expired:
                        self.output_wrapper('Timeout: Retrying request id: {}, sending to all replicas'.format(str(self._state.request_id)))
                        self._state.num_retries += 1
                        retry = 1
                        _st_label_705 += 1
                    else:
                        super()._label('_st_label_705', block=True, timeout=self._state.client_timeout)
                        _st_label_705 -= 1
                else:
                    if (_st_label_705 != 2):
                        continue
                if (_st_label_705 != 2):
                    break
        self.output_wrapper((('Local running state of client after the given set of operations: ' + str(self._state.client_running_state)) + '.'))
        self.output_wrapper((('Running state of client at the server (assuming no conflicting keys from other clients) after the given set of operations: ' + str(self._state.client_running_state_sync)) + '.'))
        if are_dicts_equal(self._state.client_running_state, self._state.client_running_state_sync):
            self.output_wrapper('\n\nTest case passed! Actual and expected running states match.\n\n')
        else:
            self.output_wrapper("\n\nTest case failed! Actual and expected running states don't match\n\n")
        super()._label('_st_label_780', block=False)
        _st_label_780 = 0
        while (_st_label_780 == 0):
            _st_label_780 += 1
            if PatternExpr_790.match_iter(self._ClientReceivedEvent_7, _BoundPattern800_=self._state.replicas_dict, _BoundPattern801_=self._state.head, SELF_ID=self._id):
                _st_label_780 += 1
            else:
                super()._label('_st_label_780', block=True)
                _st_label_780 -= 1
        super()._label('_st_label_803', block=False)
        _st_label_803 = 0
        while (_st_label_803 == 0):
            _st_label_803 += 1
            if PatternExpr_810.match_iter(self._ClientReceivedEvent_8, SELF_ID=self._id):
                _st_label_803 += 1
            else:
                super()._label('_st_label_803', block=True)
                _st_label_803 -= 1

    def sign_and_send(self, data, to_):
        data = list(data)
        data[(- 1)] = self._state.private_key.sign(str(data[(- 1)]).encode('utf-8'))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def update_client_running_state(self, running_state, type, args):
        if (type == 'put'):
            if (len(args) > 1):
                running_state[args[0]] = args[1]
            return 'OK'
        elif (type == 'get'):
            if (len(args) > 0):
                if (args[0] in running_state):
                    return running_state[args[0]]
                else:
                    return ''
        elif (type == 'slice'):
            if (len(args) > 1):
                (lower, upper) = map(int, args[1].split(':'))
                if ((args[0] in running_state) and (lower >= 0) and (upper <= len(running_state[args[0]]))):
                    running_state[args[0]] = running_state[args[0]][lower:upper]
                    return running_state[args[0]]
                else:
                    return 'fail'
        elif (type == 'append'):
            if (len(args) > 1):
                if (args[0] in running_state):
                    running_state[args[0]] = (running_state[args[0]] + args[1])
                    return 'OK'
                else:
                    return 'fail'

    def send_request(self, type, args, retry):
        args = self._state.private_key.sign(str(args).encode('utf-8'))
        if retry:
            for r in self._state.replicas:
                self.output_wrapper((((str(self._state.name) + ' is sending request for request id ') + str(self._state.request_id)) + ' in retry mode.'))
                self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args), to=r)
        else:
            self._state.request_id += 1
            self.output_wrapper((((str(self._state.name) + ' is sending request for request id ') + str(self._state.request_id)) + '.'))
            self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args), to=self._state.head)

    def validate_result(self, result, result_proof):
        if (len(result_proof) < (self._state.num_failures + 1)):
            self.output_wrapper('Number of result proofs received are less than the majority (failures + 1).')
            return (False, True)
        majority = 0
        hash = self.calculate_hash(result)
        for i in result_proof:
            if (hash == i[1]):
                majority += 1
        self.output_wrapper('Number of correct result proofs received :{}, required majority: {}'.format(majority, (self._state.num_failures + 1)))
        if (majority < (self._state.num_failures + 1)):
            return (False, True)
        elif (majority < ((2 * self._state.num_failures) + 1)):
            return (True, True)
        return (True, False)

    def calculate_hash(self, val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        elif isinstance(val, dict):
            return sha256(str.encode(str(val)), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    def output_wrapper(self, log):
        self.output('[{}][TS: {}]'.format(self._state.name, str(time())), log)

    def _Client_handler_287(self, replicas_dict_, head_, olympus):
        self._state.replicas_dict = replicas_dict_
        self._state.replicas = list()
        for (i, replica) in replicas_dict_.items():
            self._state.replicas.append(replica)
        self._state.head = head_
        self.output_wrapper(((self._state.name + ' is configured with ') + str(self._state.head)))
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_287._labels = None
    _Client_handler_287._notlabels = None

    def _Client_handler_342(self, replica_public_keys_, olympus_public_key_, olympus):
        self._state.replica_public_keys = [VerifyKey(key, encoder=HexEncoder) for key in replica_public_keys_]
        self._state.olympus_public_key = VerifyKey(olympus_public_key_, encoder=HexEncoder)
        self.output_wrapper('Received the public keys of replicas from Olympus')
        self.output_wrapper('Received the public key of Olympus.')
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_342._labels = None
    _Client_handler_342._notlabels = None

    def _Client_handler_387(self, sender_id, request_id, result_shuttle):
        if (isinstance(result_shuttle, str) and (result_shuttle == 'ERROR')):
            self.send(('Get_configuration', self._id, self._state.name, self._state.client_id, self._state.public_key), to=self._state.olympus)
            super()._label('_st_label_417', block=False)
            _st_label_417 = 0
            while (_st_label_417 == 0):
                _st_label_417 += 1
                if PatternExpr_427.match_iter(self._ClientReceivedEvent_3, _BoundPattern437_=self._state.replicas_dict, _BoundPattern438_=self._state.head, SELF_ID=self._id):
                    _st_label_417 += 1
                else:
                    super()._label('_st_label_417', block=True)
                    _st_label_417 -= 1
            return
        result_shuttle = self.verify_data_with_key(result_shuttle, self._state.replica_public_keys[sender_id])
        if (result_shuttle == None):
            self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed.'))
            return
        (result, result_proof) = result_shuttle
        (is_result__valid, is_reconfiguration_required) = self.validate_result(result, result_proof)
        if is_result__valid:
            if ((not (result == 'fail')) or (not (result == ''))):
                self.update_client_running_state(self._state.client_running_state_sync, result_proof[0][0][0], result_proof[0][0][1])
            self.output_wrapper('Valid result: {} received for request id: {}'.format(str(result), str(request_id)))
        if is_reconfiguration_required:
            self.output_wrapper('Misbehaviour detected in request id: {}! Sending reconfiguration request to Olympus'.format(request_id))
            self.send(('Reconfiguration', self._state.name, result_shuttle), to=self._state.olympus)
    _Client_handler_387._labels = None
    _Client_handler_387._notlabels = None

def are_dicts_equal(d1, d2):
    return ((len(d1) == len(d2)) and all(((k in d2) for k in d1)))
