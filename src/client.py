# -*- generated by 1.0.11 -*-
import da
PatternExpr_296 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.FreePattern('replicas_dict_'), da.pat.FreePattern('head_')])
PatternExpr_305 = da.pat.FreePattern('olympus')
PatternExpr_351 = da.pat.TuplePattern([da.pat.ConstantPattern('Keys'), da.pat.FreePattern('replica_public_keys_'), da.pat.FreePattern('olympus_public_key_')])
PatternExpr_360 = da.pat.FreePattern('olympus')
PatternExpr_396 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Operation_result_error'), da.pat.FreePattern('request_id')])
PatternExpr_423 = da.pat.TuplePattern([da.pat.ConstantPattern('running_state'), da.pat.FreePattern('running_state')])
PatternExpr_435 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Operation_result'), da.pat.FreePattern('request_id'), da.pat.FreePattern('result_shuttle')])
PatternExpr_568 = da.pat.TuplePattern([da.pat.ConstantPattern('Operation_result_reconfig'), da.pat.FreePattern('result_s')])
PatternExpr_575 = da.pat.FreePattern('olympus')
PatternExpr_733 = da.pat.BoundPattern('_BoundPattern745_')
PatternExpr_782 = da.pat.BoundPattern('_BoundPattern788_')
PatternExpr_804 = da.pat.BoundPattern('_BoundPattern810_')
PatternExpr_863 = da.pat.BoundPattern('_BoundPattern869_')
PatternExpr_913 = da.pat.ConstantPattern('Shutdown')
PatternExpr_747 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern754_')])
PatternExpr_790 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern797_')])
PatternExpr_812 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern819_')])
PatternExpr_871 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern878_')])
PatternExpr_917 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Shutdown')])
_config_object = {'channel': {'reliable', 'fifo'}}
from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError
from copy import deepcopy
from pickle import dumps, loads
from json import dumps as dump_to
from time import time, sleep
from config import *
import read_config

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_6 = []
        self._ClientReceivedEvent_7 = []
        self._ClientReceivedEvent_8 = []
        self._ClientReceivedEvent_9 = []
        self._ClientReceivedEvent_10 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_296, sources=[PatternExpr_305], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_295]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_351, sources=[PatternExpr_360], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_350]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_396, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_395]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_423, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_422]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_435, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_434]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_568, sources=[PatternExpr_575], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_567]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_6', PatternExpr_733, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_7', PatternExpr_782, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_8', PatternExpr_804, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_9', PatternExpr_863, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_10', PatternExpr_913, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, client_id, olympus, request_id, client_timeout, operations, num_failures, **rest_1315):
        super().setup(client_id=client_id, olympus=olympus, request_id=request_id, client_timeout=client_timeout, operations=operations, num_failures=num_failures, **rest_1315)
        self._state.client_id = client_id
        self._state.olympus = olympus
        self._state.request_id = request_id
        self._state.client_timeout = client_timeout
        self._state.operations = operations
        self._state.num_failures = num_failures
        self._state.name = ('Client ' + str(self._state.client_id))
        self._state.replicas = None
        self._state.replicas_dict = None
        self._state.head = None
        self._state.replica_public_keys = None
        self._state.olympus_public_key = None
        self._state.private_key = SigningKey.generate()
        self._state.public_key = self._state.private_key.verify_key.encode(encoder=HexEncoder)
        self._state.client_running_state = dict()
        self._state.client_running_state_sync = dict()
        self._state.requests_sent = 0

    def run(self):
        N = 2
        for (op_n, op) in enumerate(self._state.operations):
            self.update_client_running_state(self._state.client_running_state, op[0], op[1])
            retry = 0
            while True:
                if (((self._state.requests_sent % N) == 0) or (op_n == (len(self._state.operations) - 1))):
                    self.output_wrapper('Checking with Olympus for new configuration.')
                    self.send(('Get_configuration', self._id, self._state.name, self._state.client_id, self._state.public_key, self._state.requests_sent), to=self._state.olympus)
                    super()._label('_st_label_730', block=False)
                    _st_label_730 = 0
                    while (_st_label_730 == 0):
                        _st_label_730 += 1
                        if PatternExpr_747.match_iter(self._ClientReceivedEvent_6, _BoundPattern754_=((('Configuration_' + str(self._state.client_id)) + '_') + str(self._state.requests_sent)), SELF_ID=self._id):
                            _st_label_730 += 1
                        else:
                            super()._label('_st_label_730', block=True)
                            _st_label_730 -= 1
                    else:
                        if (_st_label_730 != 2):
                            continue
                    if (_st_label_730 != 2):
                        break
                self.send_request(op[0], op[1], retry)
                self._state.requests_sent += 1
                super()._label('_st_label_778', block=False)
                _st_label_778 = 0
                self._timer_start()
                while (_st_label_778 == 0):
                    _st_label_778 += 1
                    if (PatternExpr_790.match_iter(self._ClientReceivedEvent_7, _BoundPattern797_=('Operation_result_' + str(self._state.request_id)), SELF_ID=self._id) or PatternExpr_812.match_iter(self._ClientReceivedEvent_8, _BoundPattern819_=('Operation_result_reconfig_' + str(self._state.request_id)), SELF_ID=self._id)):
                        break
                        _st_label_778 += 1
                    elif self._timer_expired:
                        self.output_wrapper('Timeout: Retrying request id: {}, sending to all replicas'.format(str(self._state.request_id)))
                        retry = 1
                        _st_label_778 += 1
                    else:
                        super()._label('_st_label_778', block=True, timeout=self._state.client_timeout)
                        _st_label_778 -= 1
                else:
                    if (_st_label_778 != 2):
                        continue
                if (_st_label_778 != 2):
                    break
                sleep(0.1)
        self.output_wrapper((('Local running state of client after the given set of operations: ' + str(self._state.client_running_state)) + '.'))
        self.send(('get_running_state', self._id, self._state.requests_sent), to=self._state.head)
        super()._label('_st_label_860', block=False)
        _st_label_860 = 0
        while (_st_label_860 == 0):
            _st_label_860 += 1
            if PatternExpr_871.match_iter(self._ClientReceivedEvent_9, _BoundPattern878_=('running_state_' + str(self._state.requests_sent)), SELF_ID=self._id):
                _st_label_860 += 1
            else:
                super()._label('_st_label_860', block=True)
                _st_label_860 -= 1
        self.output_wrapper((('\n\nRunning state at the server after the given set of operations: ' + str(dump_to(self._state.client_running_state_sync, sort_keys=True))) + '.\n\n'))
        if self.are_dicts_valid(self._state.client_running_state, self._state.client_running_state_sync):
            self.output_wrapper('Assuming no conflicting keys from other clients:\n\nTest case passed! Actual and expected running states match.\n\n')
        else:
            self.output_wrapper("Assuming no conflicting keys from other clients:\n\nTest case failed! Actual and expected running states don't match\n\n")
        super()._label('_st_label_910', block=False)
        _st_label_910 = 0
        while (_st_label_910 == 0):
            _st_label_910 += 1
            if PatternExpr_917.match_iter(self._ClientReceivedEvent_10, SELF_ID=self._id):
                _st_label_910 += 1
            else:
                super()._label('_st_label_910', block=True)
                _st_label_910 -= 1

    def sign_and_send(self, data, to_):
        data = list(data)
        data[(- 1)] = self._state.private_key.sign(dumps(data[(- 1)]))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return loads(data.message)
        except BadSignatureError:
            return None

    def update_client_running_state(self, running_state, type, args):
        if (type == 'put'):
            if (len(args) > 1):
                running_state[args[0]] = args[1]
            return 'OK'
        elif (type == 'get'):
            if (len(args) > 0):
                if (args[0] in running_state):
                    return running_state[args[0]]
                else:
                    return ''
        elif (type == 'slice'):
            if (len(args) > 1):
                (lower, upper) = map(int, args[1].split(':'))
                if ((args[0] in running_state) and (lower >= 0) and (upper <= len(running_state[args[0]]))):
                    running_state[args[0]] = running_state[args[0]][lower:upper]
                    return running_state[args[0]]
                else:
                    return 'fail'
        elif (type == 'append'):
            if (len(args) > 1):
                if (args[0] in running_state):
                    running_state[args[0]] = (running_state[args[0]] + args[1])
                    return 'OK'
                else:
                    return 'fail'

    def send_request(self, type, args, retry):
        op_args = list(args)[:]
        args = self._state.private_key.sign(dumps(args))
        if retry:
            self.output_wrapper((((((((str(self._state.name) + ' is sending ') + str(type)) + ' request with args ') + str(op_args)) + ' for request id ') + str(self._state.request_id)) + ' in retry mode.'))
            for r in self._state.replicas:
                self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args, None), to=r)
        else:
            self._state.request_id += 1
            self.output_wrapper((((((((str(self._state.name) + ' is sending ') + str(type)) + ' request with args ') + str(op_args)) + ' for request id ') + str(self._state.request_id)) + '.'))
            self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args, None), to=self._state.head)

    def validate_result(self, result, result_proof):
        if (len(result_proof) < (self._state.num_failures + 1)):
            self.output_wrapper('Number of result proofs received are less than the majority (failures + 1).')
            return (False, True)
        majority = 0
        hash = self.calculate_hash(result)
        for i in result_proof:
            if (hash == i[1]):
                majority += 1
        self.output_wrapper('Number of correct result proofs received :{}, required majority: {}'.format(majority, (self._state.num_failures + 1)))
        if (majority < (self._state.num_failures + 1)):
            return (False, True)
        elif (majority < ((2 * self._state.num_failures) + 1)):
            return (True, True)
        return (True, False)

    def calculate_hash(self, val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        return sha256(str.encode(dump_to(val, sort_keys=True)), encoder=HexEncoder)

    def output_wrapper(self, log):
        self.output('[TS: {}][{}]'.format(str(time()), self._state.name), log)

    def are_dicts_valid(self, d1, d2):
        return all(((k in d2) for k in d1))

    def _Client_handler_295(self, replicas_dict_, head_, olympus):
        self._state.replicas_dict = replicas_dict_
        self._state.replicas = list()
        for (i, replica) in replicas_dict_.items():
            self._state.replicas.append(replica)
        self._state.head = head_
        self.output_wrapper(((self._state.name + ' is configured with ') + str(self._state.head)))
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_295._labels = None
    _Client_handler_295._notlabels = None

    def _Client_handler_350(self, replica_public_keys_, olympus_public_key_, olympus):
        self._state.replica_public_keys = [VerifyKey(key, encoder=HexEncoder) for key in replica_public_keys_]
        self._state.olympus_public_key = VerifyKey(olympus_public_key_, encoder=HexEncoder)
        self.output_wrapper('Received the public keys of replicas from Olympus')
        self.output_wrapper('Received the public key of Olympus.')
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_350._labels = None
    _Client_handler_350._notlabels = None

    def _Client_handler_395(self, sender_id, request_id):
        self.output_wrapper((((('Result during reconfiguration: Received ERROR message for request id ' + str(request_id)) + ' from Replica ') + str(sender_id)) + '.'))
    _Client_handler_395._labels = None
    _Client_handler_395._notlabels = None

    def _Client_handler_422(self, running_state):
        self._state.client_running_state_sync = running_state
    _Client_handler_422._labels = None
    _Client_handler_422._notlabels = None

    def _Client_handler_434(self, sender_id, request_id, result_shuttle):
        result_shuttle_signed = deepcopy(result_shuttle)
        result_shuttle = self.verify_data_with_key(result_shuttle, self._state.replica_public_keys[sender_id])
        if (result_shuttle == None):
            self.output_wrapper((('Signature verification of message sent by Replica ' + str(sender_id)) + ' has failed.'))
            self.output_wrapper('Misbehaviour detected in request id: {}! Sending reconfiguration request to Olympus'.format(request_id))
            self.send(('Reconfiguration', self._state.name, [result_shuttle_signed, result_shuttle]), to=self._state.olympus)
            return
        (result, result_proof) = result_shuttle
        (is_result__valid, is_reconfiguration_required) = self.validate_result(result, result_proof)
        if is_result__valid:
            if ((not (result == 'fail')) or (not (result == ''))):
                self.update_client_running_state(self._state.client_running_state_sync, result_proof[0][0][0], result_proof[0][0][1])
            self.output_wrapper('Result: {} received for request id: {}'.format(str(result), str(request_id)))
        if is_reconfiguration_required:
            self.output_wrapper('Misbehaviour detected in request id: {}! Sending reconfiguration request to Olympus'.format(request_id))
            self.send(('Reconfiguration', self._state.name, result_shuttle), to=self._state.olympus)
    _Client_handler_434._labels = None
    _Client_handler_434._notlabels = None

    def _Client_handler_567(self, result_s, olympus):
        (result, result_stmt, request_id_) = result_s
        if ((not (result == 'fail')) or (not (result == ''))):
            self.update_client_running_state(self._state.client_running_state_sync, result_stmt[0][0], result_stmt[0][1])
        self.output_wrapper('Result from Olympus: {} received from Olympus during reconfiguration for request id: {}'.format(str(result), str(request_id_)))
    _Client_handler_567._labels = None
    _Client_handler_567._notlabels = None
