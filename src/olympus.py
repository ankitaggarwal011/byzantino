# -*- generated by 1.0.10 -*-
import da
PatternExpr_529 = da.pat.TuplePattern([da.pat.ConstantPattern('ACK'), da.pat.FreePattern('sender')])
PatternExpr_539 = da.pat.TuplePattern([da.pat.ConstantPattern('Get_configuration'), da.pat.FreePattern('client'), da.pat.FreePattern('client_name'), da.pat.FreePattern('client_id'), da.pat.FreePattern('client_public_key'), da.pat.FreePattern('request_num')])
PatternExpr_887 = da.pat.TuplePattern([da.pat.ConstantPattern('caught_up'), da.pat.ConstantPattern(None), da.pat.ConstantPattern(None)])
PatternExpr_932 = da.pat.TuplePattern([da.pat.ConstantPattern('wedge'), da.pat.FreePattern('hist'), da.pat.FreePattern('checkpt_proof'), da.pat.FreePattern('checkpoint'), da.pat.FreePattern('replica_id')])
PatternExpr_1148 = da.pat.TuplePattern([da.pat.ConstantPattern('caught_up'), da.pat.FreePattern('hash_running_state'), da.pat.FreePattern('replica_id'), da.pat.FreePattern('most_recent_result')])
PatternExpr_1314 = da.pat.TuplePattern([da.pat.ConstantPattern('response_get_running_state'), da.pat.ConstantPattern(None), da.pat.ConstantPattern(None)])
PatternExpr_1340 = da.pat.TuplePattern([da.pat.ConstantPattern('Reconfiguration'), da.pat.FreePattern('sender'), da.pat.FreePattern('proof_of_misbehavior')])
PatternExpr_1402 = da.pat.TuplePattern([da.pat.ConstantPattern('response_get_running_state'), da.pat.FreePattern('replica_id'), da.pat.FreePattern('replica_running_state')])
PatternExpr_1886 = da.pat.TuplePattern([da.pat.ConstantPattern('ACK'), da.pat.ConstantPattern(None)])
PatternExpr_1909 = da.pat.ConstantPattern('Shutdown')
PatternExpr_1893 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('ACK'), da.pat.ConstantPattern(None)])])
PatternExpr_1913 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Shutdown')])
PatternExpr_1323 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('response_get_running_state'), da.pat.ConstantPattern(None), da.pat.ConstantPattern(None)])])
_config_object = {'channel': {'reliable', 'fifo'}}
from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError
from json import dumps
from ast import literal_eval
replica_module = da.import_da('replica')
from time import time, sleep
from config import *
import read_config

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._OlympusReceivedEvent_2 = []
        self._OlympusReceivedEvent_5 = []
        self._OlympusReceivedEvent_8 = []
        self._OlympusReceivedEvent_9 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_529, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_528]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_1', PatternExpr_539, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_538]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_2', PatternExpr_887, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_3', PatternExpr_932, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_931]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_4', PatternExpr_1148, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1147]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_5', PatternExpr_1314, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_6', PatternExpr_1340, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1339]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_7', PatternExpr_1402, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1401]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_8', PatternExpr_1886, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_9', PatternExpr_1909, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, name, num_replicas, num_failures, all_replica_conf_failures, head_timeout, replica_timeout, checkpt_interval, **rest_1935):
        super().setup(name=name, num_replicas=num_replicas, num_failures=num_failures, all_replica_conf_failures=all_replica_conf_failures, head_timeout=head_timeout, replica_timeout=replica_timeout, checkpt_interval=checkpt_interval, **rest_1935)
        self._state.name = name
        self._state.num_replicas = num_replicas
        self._state.num_failures = num_failures
        self._state.all_replica_conf_failures = all_replica_conf_failures
        self._state.head_timeout = head_timeout
        self._state.replica_timeout = replica_timeout
        self._state.checkpt_interval = checkpt_interval
        self._state.state = 'NORMAL'
        self._state.num_failures = self._state.num_failures
        self._state.replicas = dict()
        self._state.replica_private_keys = list()
        self._state.replica_public_keys = list()
        self._state.head = None
        self._state.tail = None
        self._state.running_state_validated = 0
        self._state.wedged_responses = list()
        self._state.quorum_start_index = 0
        self._state.quorum = list()
        self._state.chosen_running_state = None
        self._state.running_states_received = 0
        self._state.ignore_further_caught_up_messages = 0
        self._state.checkpoint = 0
        self._state.recent_results = list()
        self._state.slots_used = 0
        self._state.private_key = SigningKey.generate()
        self._state.public_key = self._state.private_key.verify_key.encode(encoder=HexEncoder)
        self._state.configuration_number = 0
        self._state.clients = dict()
        self._state.client_keys = dict()
        all_replica_failures = self._state.all_replica_conf_failures.get(self._state.configuration_number, {})
        for i in range(self._state.num_replicas):
            replica_failures = all_replica_failures.get(i, {})
            running_state = dict()
            slot_number = 0
            if (i == 0):
                replica = self.new(replica_module.Replica, args=(i, 'Head', running_state, replica_failures, self._state.head_timeout, self._state.public_key, self._state.checkpt_interval, slot_number))
                self._state.head = replica
            elif (i == (self._state.num_replicas - 1)):
                replica = self.new(replica_module.Replica, args=(i, 'Tail', running_state, replica_failures, self._state.replica_timeout, self._state.public_key, self._state.checkpt_interval, slot_number))
                self._state.tail = replica
            else:
                replica = self.new(replica_module.Replica, args=(i, ('Replica ' + str(i)), running_state, replica_failures, self._state.replica_timeout, self._state.public_key, self._state.checkpt_interval, slot_number))
            self._state.replicas[i] = replica
            replica_name = ('Replica ' + str(i))
            self.output_wrapper('Olympus created replica process: {}'.format(replica_name))
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder=HexEncoder)
            self.output_wrapper('Olympus created keys for replica process: {}. Public key: {}'.format(replica_name, str(verify_key)))
            self._state.replica_private_keys.append(signing_key)
            self._state.replica_public_keys.append(verify_key)

    def run(self):
        for (i, r) in self._state.replicas.items():
            self._start(r)
            self.sign_and_send(('Configuration', self._id, self._state.replicas, self._state.head, self._state.tail, [self._state.replica_public_keys, self._state.configuration_number]), r)
            self.send(('Key', self._state.replica_private_keys[i]), to=r)
        super()._label('_st_label_1883', block=False)
        _st_label_1883 = 0
        while (_st_label_1883 == 0):
            _st_label_1883 += 1
            if PatternExpr_1893.match_iter(self._OlympusReceivedEvent_8, SELF_ID=self._id):
                _st_label_1883 += 1
            else:
                super()._label('_st_label_1883', block=True)
                _st_label_1883 -= 1
        super()._label('_st_label_1906', block=False)
        _st_label_1906 = 0
        while (_st_label_1906 == 0):
            _st_label_1906 += 1
            if PatternExpr_1913.match_iter(self._OlympusReceivedEvent_9, SELF_ID=self._id):
                _st_label_1906 += 1
            else:
                super()._label('_st_label_1906', block=True)
                _st_label_1906 -= 1

    def begin_reconfiguration(self):
        if (self._state.state == 'RECONFIGURATION'):
            self.output_wrapper('System is already in reconfiguration. Ignoring new reconfiguration command.')
            return
        self._state.state = 'RECONFIGURATION'
        self.output_wrapper(('Sending wedge requests to replicas: ' + str(self._state.replicas)))
        for (i, r) in self._state.replicas.items():
            self.output_wrapper(('Sending wedge requests to replica: ' + str(i)))
            self.send('wedge_request', to=r)

    def select_quorum(self):
        self.output_wrapper('Selecting a new quorum.')
        self._state.quorum = list()
        longest_history = list()
        furthest_checkpoint = self._state.checkpoint
        self._state.wedged_responses.sort(reverse=True, key=(lambda x: (len(x[0]) + x[2])))
        while ((self._state.quorum_start_index < len(self._state.wedged_responses)) and (len(self._state.quorum) < (self._state.num_failures + 1))):
            longest_history = self._state.wedged_responses[self._state.quorum_start_index][0]
            furthest_checkpoint = self._state.wedged_responses[self._state.quorum_start_index][2]
            for w_resp in self._state.wedged_responses[self._state.quorum_start_index:]:
                replica_history = w_resp[0][(furthest_checkpoint - w_resp[2]):]
                if (replica_history == longest_history[:len(replica_history)]):
                    self._state.quorum.append(w_resp)
                if (len(self._state.quorum) == (self._state.num_failures + 1)):
                    break
            self._state.quorum_start_index += 1
        if (len(self._state.quorum) == 0):
            self.output_wrapper((("No quorum formed. System can't handle more than " + str(self._state.num_failures)) + '.'))
            return
        self._state.checkpoint = furthest_checkpoint
        quorum_replicas = [i[1] for i in self._state.quorum]
        self.output_wrapper((((('Quorum is selected with Replicas ' + str(quorum_replicas)) + ' and checkpoint at ') + str(self._state.checkpoint)) + '.'))
        self._state.slots_used = (furthest_checkpoint + len(longest_history))
        self._state.ignore_further_caught_up_messages = 0
        self._state.running_states_received = 0
        self._state.chosen_running_state = None
        self._state.recent_results = list()
        for i in self._state.quorum:
            replica_history = i[0][(furthest_checkpoint - i[2]):]
            gap = longest_history[len(replica_history):]
            self.send(('catch_up', gap), to=self._state.replicas[i[1]])
        super()._label('_st_label_884', block=False)

        def ExistentialOpExpr_885():
            for (_, _, (_ConstantPattern904_, _ConstantPattern906_, _ConstantPattern908_)) in self._OlympusReceivedEvent_2:
                if (_ConstantPattern904_ == 'caught_up'):
                    if (_ConstantPattern906_ == None):
                        if (_ConstantPattern908_ == None):
                            if (self._state.running_states_received == len(self._state.quorum)):
                                return True
            return False
        _st_label_884 = 0
        self._timer_start()
        while (_st_label_884 == 0):
            _st_label_884 += 1
            if ExistentialOpExpr_885():
                pass
                _st_label_884 += 1
            elif self._timer_expired:
                if (self._state.running_states_received < len(self._state.quorum)):
                    self.output_wrapper('Number of running states received are less than the size of quorum.')
                    self.select_quorum()
                _st_label_884 += 1
            else:
                super()._label('_st_label_884', block=True, timeout=2)
                _st_label_884 -= 1

    def validate_checkpoint_proof(self, checkpt_p):
        if ((len(checkpt_p) == 0) or (not (len(checkpt_p) == len(self._state.replicas)))):
            return False
        checkpt = checkpt_p[0]
        if ((not (checkpt_p.count(checkpt) == len(checkpt_p))) or (checkpt[0] <= self._state.checkpoint)):
            return False
        return True

    def validate_order_proof(self, order_p):
        (slot_number, operation, configuration, order_stmt, request_id) = order_p
        for stmt in order_stmt:
            if ((not (stmt[0] == slot_number)) or (not (stmt[1] == operation)) or (not (stmt[2] == configuration))):
                return False
        return True

    def send_most_recent_result_to_client(self):
        first_dict = self._state.recent_results[0]
        for (each_client, each_result) in first_dict.items():
            result_consistent = 1
            for each_dict in self._state.recent_results:
                if (not (each_dict[each_client][1] == each_result[1])):
                    result_consistent = 0
            request_id = each_result[2]
            if result_consistent:
                self.output_wrapper((('During reconfiguration, Olympus sending the most recent result for Client ' + str(each_client)) + '.'))
                self.send(('Operation_result_reconfig', each_result), to=self._state.clients[each_client])
                self.send(('Operation_result_reconfig_' + str(request_id)), to=self._state.clients[each_client])

    def get_running_state_from_quorum(self):
        self.output_wrapper('Getting the running state from the quorum.')
        for each_member in self._state.quorum:
            if (not self._state.running_state_validated):
                self.send('get_running_state', to=self._state.replicas[each_member[1]])
                super()._label('_st_label_1311', block=False)
                _st_label_1311 = 0
                while (_st_label_1311 == 0):
                    _st_label_1311 += 1
                    if PatternExpr_1323.match_iter(self._OlympusReceivedEvent_5, SELF_ID=self._id):
                        _st_label_1311 += 1
                    else:
                        super()._label('_st_label_1311', block=True)
                        _st_label_1311 -= 1
                else:
                    if (_st_label_1311 != 2):
                        continue
                if (_st_label_1311 != 2):
                    break

    def validate_proof_of_misbehavior(self, proof_of_misbehavior):
        (result, result_proof) = proof_of_misbehavior
        if (len(result_proof) < (self._state.num_failures + 1)):
            return True
        majority = 0
        hash = self.calculate_hash(result)
        for i in result_proof:
            if (hash == i[1]):
                majority += 1
        if (majority < ((2 * self._state.num_failures) + 1)):
            return True
        return False

    def calculate_hash(self, val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        elif isinstance(val, dict):
            return sha256(str.encode(dumps(val, sort_keys=True)), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    def sign_and_send(self, data, to_):
        data = list(data)
        data[(- 1)] = self._state.private_key.sign(str(data[(- 1)]).encode('utf-8'))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def init_new_configuration(self, new_running_state):
        self._state.configuration_number += 1
        self._state.replicas = dict()
        self._state.replica_private_keys = list()
        self._state.replica_public_keys = list()
        self._state.head = None
        self._state.tail = None
        all_replica_failures = self._state.all_replica_conf_failures.get(self._state.configuration_number, {})
        for i in range(self._state.num_replicas):
            replica_failures = all_replica_failures.get(i, {})
            if (i == 0):
                replica = self.new(replica_module.Replica, args=(i, 'Head', new_running_state, replica_failures, self._state.head_timeout, self._state.public_key, self._state.checkpt_interval, self._state.slots_used))
                self._state.head = replica
            elif (i == (self._state.num_replicas - 1)):
                replica = self.new(replica_module.Replica, args=(i, 'Tail', new_running_state, replica_failures, self._state.replica_timeout, self._state.public_key, self._state.checkpt_interval, self._state.slots_used))
                self._state.tail = replica
            else:
                replica = self.new(replica_module.Replica, args=(i, ('Replica ' + str(i)), new_running_state, replica_failures, self._state.replica_timeout, self._state.public_key, self._state.checkpt_interval, self._state.slots_used))
            self._state.replicas[i] = replica
            replica_name = ('Replica ' + str(i))
            self.output_wrapper('Olympus created replica process: {}'.format(replica_name))
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder=HexEncoder)
            self.output_wrapper('Olympus created keys for replica process: {}. Public key: {}'.format(replica_name, str(verify_key)))
            self._state.replica_private_keys.append(signing_key)
            self._state.replica_public_keys.append(verify_key)
        self._state.running_state_validated = 0
        self._state.quorum = list()
        self._state.wedged_responses = list()
        self._state.quorum_start_index = 0
        self._state.chosen_running_state = None
        self._state.running_states_received = 0
        self._state.ignore_further_caught_up_messages = 0
        self._state.checkpoint = 0
        self._state.recent_results = list()
        self.output_wrapper('Replacing the old replicas with new replicas.')
        for (i, r) in self._state.replicas.items():
            self._start(r)
            self.sign_and_send(('Configuration', self._id, self._state.replicas, self._state.head, self._state.tail, [self._state.replica_public_keys, self._state.configuration_number]), r)
            self.send(('Key', self._state.replica_private_keys[i]), to=r)
        self.output_wrapper((((('Reconfiguration is successful. Configuration is changed from ' + str((self._state.configuration_number - 1))) + ' to ') + str(self._state.configuration_number)) + '.'))
        self.output_wrapper(('New replicas: ' + str(self._state.replicas)))
        self._state.state = 'NORMAL'

    def output_wrapper(self, log):
        self.output('[TS: {}][{}]'.format(str(time()), self._state.name), log)

    def _Olympus_handler_528(self, sender):
        pass
    _Olympus_handler_528._labels = None
    _Olympus_handler_528._notlabels = None

    def _Olympus_handler_538(self, client, client_name, client_id, client_public_key, request_num):
        self._state.client_keys[client_id] = VerifyKey(client_public_key, encoder=HexEncoder)
        self._state.clients[client_id] = client
        self.send(('Configuration', self._state.replicas, self._state.head), to=client)
        self.send(('Keys', self._state.replica_public_keys, self._state.public_key), to=client)
        self.send(((('Configuration_' + str(client_id)) + '_') + str(request_num)), to=client)
        for (i, r) in self._state.replicas.items():
            self.send(('Client_keys', client_id, client_public_key), to=r)
        self.output_wrapper('Received public key: {} from client: {}'.format(str(client_public_key), str(client_name)))
        self.output_wrapper((('Configuration sent to ' + str(client_name)) + '.'))
    _Olympus_handler_538._labels = None
    _Olympus_handler_538._notlabels = None

    def _Olympus_handler_931(self, hist, checkpt_proof, checkpoint, replica_id):
        self.output_wrapper(('Wedge message from Replica ' + str(replica_id)))
        for order_p in hist:
            if (not self.validate_order_proof(order_p)):
                self.output_wrapper((((('Order Proof in history: ' + str(order_p)) + ', sent with wedge response of Replica ') + str(replica_id)) + ' are invalid.'))
                return
        if ((not (checkpt_proof == None)) and (not self.validate_checkpoint_proof(checkpt_proof))):
            self.output_wrapper((((('Checkpoint Proof: ' + str(checkpt_proof)) + ', sent with wedge response of Replica ') + str(replica_id)) + ' is invalid.'))
            return
        self._state.wedged_responses.append([sorted([(o_p[:(- 2)] + o_p[(- 1):]) for o_p in hist], key=(lambda x: x[0])), replica_id, checkpoint])
        if (len(self._state.wedged_responses) == (self._state.num_failures + 1)):
            self.output_wrapper((('Received ' + str(len(self._state.wedged_responses))) + ' wedged responses.'))
            self.select_quorum()
    _Olympus_handler_931._labels = None
    _Olympus_handler_931._notlabels = None

    def _Olympus_handler_1147(self, hash_running_state, replica_id, most_recent_result):
        self.output_wrapper(('Caught up message received from Replica ' + str(replica_id)))
        if self._state.ignore_further_caught_up_messages:
            return
        if (not ((self._state.chosen_running_state == None) or (hash_running_state == self._state.chosen_running_state))):
            self.output_wrapper("Chosen quorum is not valid as the hash of all running states don't match.")
            self._state.ignore_further_caught_up_messages = 1
            self.select_quorum()
            return
        self._state.running_states_received += 1
        self._state.recent_results.append(most_recent_result)
        self._state.chosen_running_state = hash_running_state
        if (self._state.running_states_received == len(self._state.quorum)):
            self.send_most_recent_result_to_client()
            self.get_running_state_from_quorum()
    _Olympus_handler_1147._labels = None
    _Olympus_handler_1147._notlabels = None

    def _Olympus_handler_1339(self, sender, proof_of_misbehavior):
        self.output_wrapper((('Reconfiguration request received from ' + str(sender)) + '.'))
        if ((isinstance(proof_of_misbehavior, int) and (proof_of_misbehavior == self._state.configuration_number)) or (isinstance(proof_of_misbehavior, list) and self.validate_proof_of_misbehavior(proof_of_misbehavior))):
            self.output_wrapper((('Reconfiguration request sent by ' + str(sender)) + ' is valid. Starting reconfiguration.'))
            self.begin_reconfiguration()
        else:
            self.output_wrapper((('Proof of misbehavior sent by ' + str(sender)) + " is not valid. If it is sent by replica, its configuration doesn't match and if its sent by client, proof of misbehavior is invalid."))
    _Olympus_handler_1339._labels = None
    _Olympus_handler_1339._notlabels = None

    def _Olympus_handler_1401(self, replica_id, replica_running_state):
        self.output_wrapper((('Response to get_running_state from Replica ' + str(replica_id)) + ' received by Olympus.'))
        self.output_wrapper('Validating the running_state with the quorum.')
        if (self.calculate_hash(replica_running_state) == self._state.chosen_running_state):
            self._state.running_state_validated = 1
            self.output_wrapper('Running state validated with the Quorum. Initializing new configuration.')
            self.init_new_configuration(replica_running_state)
    _Olympus_handler_1401._labels = None
    _Olympus_handler_1401._notlabels = None
