from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError
from ast import literal_eval
from config import *
import read_config
import sys
import getopt

config(channel = {'reliable', 'fifo'})

client_running_state = dict()

class Replica(process):
    
    def setup(id, name, replica_failures, replica_timeout):
        output("replica failures: " + str(replica_failures))
        self.status = 0 # PENDING
        self.running_state = dict() # supports put, get, slice, and append operations
        self.order_proof = list()
        self.result_proof = list()
        self.result_cache = dict()
        self.slot_number = 0
        self.last_slot_number = 0
        self.olympus = None
        self.replicas = None
        self.head = None
        self.tail = None
        self.replica_public_keys = None
        self.private_key = None
        self.client_keys = dict()
        self.configuration = None

        self.messages_received_from_client = {} # messages received for each client
        self.messages_shuttle = {} # shuttles received for each client
        self.messages_result_shuttle = {} # result shuttles received for each client
        self.messages_forwarded_request = {} # forwarded requests received for each client
    
    def run():
        status = 1 # ACTIVE
        await(received(('Shutdown'), from_ = olympus))

    def receive(msg = ('Shutdown'), from_ = olympus):
        status = 2 # IMMUTABLE
        output(name + ' is immutable and shutting down.')
    
    def receive(msg = ('Configuration', olympus_, replicas_, head_, tail_, replica_public_keys_, config_number)):
        olympus = olympus_
        replicas = replicas_
        head = head_
        tail = tail_
        replica_public_keys = [VerifyKey(key, encoder = HexEncoder) for key in replica_public_keys_]
        configuration = config_number
        output(name + ' is configured.')
        send(('ACK', name), to = olympus)

    def receive(msg = ('Key', private_key_)):
        private_key = private_key_
        output(name + ' have received its private key from Olympus.')
        send(('ACK', name), to = olympus)

    def receive(msg = ('Client_keys', client_id, client_public_key)):
        client_keys[client_id] = VerifyKey(client_public_key, encoder = HexEncoder)
        send(('ACK', name), to = olympus)

    def receive(msg = (sender_id, 'Request', type, request_from, client, request_id, client_id, args)):
        output(str(type) + ' request with request id ' + str(request_id) + ' received by ' + name + '.')
        if status == 0:
            output(name + ' is in PENDING state.')
        elif status == 1:
            output(name + ' is in ACTIVE state.')
        elif status == 2:
            output(name + ' is in IMMUTABLE state.')
        if status == 1: # if replica is ACTIVE
            if request_from == client:
                # client_request failure trigger
                if client_id not in messages_received_from_client:
                    messages_received_from_client[client_id] = 0
                is_trigger, scenario = check_failure(replica_failures, client_id, messages_received_from_client[client_id], FailureType.client_request)
                if is_trigger:
                    # trigger this failure
                    current_failure_scenario = scenario
                    output("Replica {}: Trigger client request failure for client_id: {} and message count: {}, scenario: {}".format(name, client_id, messages_received_from_client[client_id], current_failure_scenario));

                messages_received_from_client[client_id] += 1
                # Verification of digital signature of client
                try:
                    client_keys[client_id].verify(args)
                    args = literal_eval(args.message.decode('utf-8'))
                except BadSignatureError:
                    output('Verification of message sent by Client ' + str(client_id) + ' has failed.')
                    return

                if request_id in result_cache:
                    sign_and_send(('Operation_result', result_cache[request_id]), client)
                    output('Result sent from cache of ' + name + '.')
                    return
                elif self != head:
                    sign_and_send(('Request', type, self, client, request_id, client_id, args), head)
                    if await(received(('Result_shuttle_' + str(request_id)))):
                        pass
                    elif timeout(replica_timeout):
                        send(('Reconfiguration', name, None), to = olympus)
                    return
            else:
                # Verification of digital signature of replicas
                try:
                    replica_public_keys[sender_id].verify(args)
                    args = literal_eval(args.message.decode('utf-8'))
                except BadSignatureError:
                    output('Verification of message sent by Replica ' + str(sender_id) + ' has failed.')
                    return
            if self == head:
                if request_from != client:
                    # forwarded_request failure trigger
                    if client_id not in messages_forwared_request:
                        messages_forwared_request[client_id] = 0
                    is_trigger, scenario = check_failure(replica_failures, client_id, messages_forwared_request[client_id], FailureType.forwarded_request)
                    if is_trigger:
                        # trigger this failure
                        current_failure_scenario = scenario
                        output("Replica {}: Trigger forwarded request failure for client_id: {} and message count: {}, scenario: {}".format(name, client_id, messages_forwared_request[client_id], current_failure_scenario));
                    messages_forwared_request[client_id] += 1
                result = update_running_state(type, args)
                slot_number += 1
                order_stmt = [[slot_number, (type, args), configuration]] # (type, args) is operation (o)
                order_proof = [slot_number, (type, args), configuration, order_stmt]
                result_proof = [[(type, args), calculate_hash(result)]] # add result stmt
                shuttle = (order_proof, result_proof)
                sign_and_send(('Request', type, self, client, request_id, client_id, shuttle), replicas[id + 1])
                last_slot_number = slot_number
                if await(received(('Result_shuttle_' + str(request_id)))):
                    pass
                elif timeout(replica_timeout):
                    send(('Reconfiguration', name, None), to = olympus)
            else:
                # shuttle failure trigger
                if client_id not in messages_shuttle:
                    messages_shuttle[client_id] = 0
                is_trigger, scenario = check_failure(replica_failures, client_id, messages_shuttle[client_id], FailureType.shuttle)
                if is_trigger:
                    # trigger this failure
                    current_failure_scenario = scenario
                    output("Replica {}: Trigger shuttle failure for client_id: {} and message count: {}, scenario: {}".format(name, client_id, messages_shuttle[client_id], current_failure_scenario));
                messages_shuttle[client_id] += 1
                
                if validate_shuttle(args):
                    order_proof, result_proof = args
                    slot_number, operation, configuration, order_stmt = order_proof
                    last_slot_number = slot_number
                    type, operation_args = operation
                    result = update_running_state(type, operation_args)
                    order_proof[3].append([slot_number, (type, operation_args), configuration]) # append to order_stmt
                    result_proof.append([(type, operation_args), calculate_hash(result)]) # append result stmt
                    shuttle = (order_proof, result_proof)
                    if self == tail:
                        result_shuttle = [result, result_proof]
                        sign_and_send(('Operation_result', result_shuttle), client)
                        send(('Operation_result_' + str(request_id)), to = client)
                        sign_and_send(('Result_shuttle', self, request_id, client_id, result_shuttle), tail)
                    else:
                        sign_and_send(('Request', type, self, client, request_id, client_id, shuttle), replicas[id + 1])
                        if await(received(('Result_shuttle_' + str(request_id)))):
                            pass
                        elif timeout(replica_timeout):
                            send(('Reconfiguration', name, None), to = olympus)
                else:
                    send(('Reconfiguration', name, None), to = olympus)

    def receive(msg = (sender_id, 'Result_shuttle', request_from, request_id, client_id, result_shuttle)):
        # result_shuttle failure trigger
        if client_id not in messages_result_shuttle:
            messages_result_shuttle[client_id] = 0
        is_trigger, scenario = check_failure(replica_failures, client_id, messages_result_shuttle[client_id], FailureType.result_shuttle)
        if is_trigger:
            # trigger this failure
            current_failure_scenario = scenario
            output("Replica {}: Trigger result shuttle failure for client_id: {} and message count: {}, scenario: {}".format(name, client_id, messages_result_shuttle[client_id], current_failure_scenario));
        messages_result_shuttle[client_id] += 1

        try:
            replica_public_keys[sender_id].verify(result_shuttle)
            result_shuttle = literal_eval(result_shuttle.message.decode('utf-8'))
        except BadSignatureError:
            output('Verification of message sent by Replica ' + sender_id + ' has failed.')
            return
        if validate_result_shuttle(result_shuttle):
            result_cache[request_id] = result_shuttle
            if self != head:
                sign_and_send(('Result_shuttle', self, request_id, client_id, result_shuttle), replicas[id - 1])
                send(('Result_shuttle_' + str(request_id)), to = replicas[id - 1])
            output('Result shuttle is at ' + name + '.')
        else:
            output('Result shuttle sent by Replica ' + sender_id + ' is not valid.')
            send(('Reconfiguration', name, None), to = olympus)

    def update_running_state(type, args):
        if type == 'put':
            if len(args) > 1:
                running_state[args[0]] = args[1]
            return 'OK'
        elif type == 'get':
            if len(args) > 0:
                if args[0] in running_state:
                    return running_state[args[0]]
                else:
                    return ''
        elif type == 'slice':
            if len(args) > 1:
                if args[0] in running_state and args[1] <= len(running_state[args[0]]):
                    running_state[args[0]] = running_state[args[0]][int(args[1]):]
                    return running_state[args[0]]
                else:
                    return 'fail'
        elif type == 'append':
            if len(args) > 1:
                if args[0] in running_state:
                    running_state[args[0]] = running_state[args[0]] + args[1]
                    return 'OK'
                else:
                    return 'fail'
    
    def calculate_hash(val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder = HexEncoder)
        return sha256(val, encoder = HexEncoder)

    def validate_shuttle(shuttle):
        order_proof, result_proof = shuttle
        slot_number, operation, configuration, order_stmt = order_proof
        if last_slot_number != slot_number - 1:
            return False
        for stmt in order_stmt:
            if stmt[0] != slot_number or stmt[1] != operation or stmt[2] != configuration:
                return False
        hash = result_proof[0][1]
        for result_stmt in result_proof:
            if result_stmt[0] != operation or result_stmt[1] != hash:
                return False
        return True

    def validate_result_shuttle(result_shuttle):
        result, result_proof = result_shuttle
        hash = calculate_hash(result)
        for i in result_proof:
            if hash != i[1]:
                return False
        return True

    def sign_and_send(data, to_):
        data = [id] + list(data)
        data[-1] = private_key.sign(str(data[-1]).encode('utf-8'))
        send(tuple(data), to = to_)

    ## failure trigger methods for replica
    def check_failure(replica_failures, source_id, source_message_count, required_type):
        for i, failure in enumerate(replica_failures):
            oper = failure.operands
            if failure.failure_type == required_type and source_id == oper[0] and source_message_count == oper[1]:
                return (True, failure)

        return (False, None)

class Olympus(process):
    
    def setup(name, num_replicas, all_replica_conf_failures, head_timeout, replica_timeout):
        self.replicas = list()
        self.replica_private_keys = list()
        self.replica_public_keys = list()
        self.head = None
        self.tail = None
        self.private_key = SigningKey.generate()
        self.public_key = self.private_key.verify_key.encode(encoder = HexEncoder)
        self.configuration_number = 0 # default configuration for phase 2
        all_replica_failures = all_replica_conf_failures.get(self.configuration_number, {})
        for i in range(num_replicas):
            replica_failures = all_replica_failures.get(i, {})
            if i == 0:
                replica = new(Replica, args=(i, 'Head', replica_failures, head_timeout))
                self.head = replica
            elif i == num_replicas - 1:
                replica = new(Replica, args=(i, 'Tail', replica_failures, replica_timeout))
                self.tail = replica
            else:
                replica = new(Replica, args=(i, 'Replica ' + str(i), replica_failures, replica_timeout))
            self.replicas.append(replica)
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder = HexEncoder)
            self.replica_private_keys.append(signing_key)
            self.replica_public_keys.append(verify_key)
    
    def receive(msg = ('ACK', sender)):
        output('ACK from ' + str(sender) + '.')

    def receive(msg = ('Get_configuration', client, client_name, client_id, client_public_key)):
        send(('Configuration', replicas, head), to = client)
        send(('Keys', replica_public_keys), to = client)
        send(('Client_keys', client_id, client_public_key), to = replicas)
        output('Configuration sent to ' + str(client_name) + '.')

    def receive(msg = ('Reconfiguration', sender, proof_of_misbehavior)):
        output('Reconfiguration request received from ' + str(sender) + '.')
        output('No reconfiguration mechanism implemented yet.')
        # Reconfigure and send new configuration to client and replicas

    def run():
        start(replicas)
        send(('Configuration', self, replicas, head, tail, replica_public_keys, configuration_number), to = replicas)
        for i in range(len(replicas)):
            send(('Key', replica_private_keys[i]), to = replicas[i])
        await(received(('ACK', None)))
        await(received(('Shutdown')))

class Client(process):
    
    def setup(client_id, olympus, request_id, client_timeout, operations):
        self.name = 'Client ' + str(client_id)
        self.replicas = None
        self.head = None
        self.replica_public_keys = None
        self.private_key = SigningKey.generate()
        self.public_key = self.private_key.verify_key.encode(encoder = HexEncoder)

    def receive(msg = ('Configuration', replicas_, head_), from_ = olympus):
        replicas = replicas_
        head = head_
        output(name + ' is configured.')
        send(('ACK', name), to = olympus)

    def receive(msg = ('Keys', replica_public_keys_), from_ = olympus):
        replica_public_keys = [VerifyKey(key, encoder = HexEncoder) for key in replica_public_keys_]
        output(name + ' received the public keys of replicas from Olympus.')
        send(('ACK', name), to = olympus)

    def receive(msg = (sender_id, 'Operation_result', result_shuttle)):
        try:
            replica_public_keys[sender_id].verify(result_shuttle)
            result_shuttle = literal_eval(result_shuttle.message.decode('utf-8'))
        except BadSignatureError:
            output('Verification of message sent by Replica ' + sender_id + ' has failed.')
            return
        result, result_proof = result_shuttle
        if validate_result(result, result_proof):
            output(result + ' received by ' + name + '.')
        else:
            # send reconfiguration request to Olympus with proof of misbehavior
            send(('Reconfiguration', name, result_shuttle), to = olympus)

    def run():
        if replicas is None:
            send(('Get_configuration', self, name, client_id, public_key), to = olympus)
            await(received(('Configuration', replicas, head)))
        for op in operations:
            output('Local client state is updated with response ' + update_client_running_state(op[0], op[1]) + '.')
            retry = 0
            while True:
                send_request(op[0], op[1], retry)
                if await(received(('Operation_result_' + str(request_id)))):
                    break
                elif timeout(client_timeout):
                    output('Timeout: Retrying.')
                    retry = 1
        output('Local running state of client after the given set of operations: ' + str(client_running_state) + '.')
        await(received('Shutdown'))

    def update_client_running_state(type, args):
        if type == 'put':
            if len(args) > 1:
                client_running_state[args[0]] = args[1]
            return 'OK'
        elif type == 'get':
            if len(args) > 0:
                if args[0] in client_running_state:
                    return client_running_state[args[0]]
                else:
                    return ''
        elif type == 'slice':
            if len(args) > 1:
                if args[0] in client_running_state and args[1] <= len(client_running_state[args[0]]):
                    client_running_state[args[0]] = client_running_state[args[0]][int(args[1]):]
                    return client_running_state[args[0]]
                else:
                    return 'fail'
        elif type == 'append':
            if len(args) > 1:
                if args[0] in client_running_state:
                    client_running_state[args[0]] = client_running_state[args[0]] + args[1]
                    return 'OK'
                else:
                    return 'fail'

    def send_request(type, args, retry):
        args = private_key.sign(str(args).encode('utf-8'))
        if retry:
            send((None, 'Request', type, self, self, request_id, client_id, args), to = replicas)
        else:
            request_id += 1
            send((None, 'Request', type, self, self, request_id, client_id, args), to = head)

    def validate_result(result, result_proof):
        hash = calculate_hash(result)
        for i in result_proof:
            if hash != i[1]:
                return False
        return True

    def calculate_hash(val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder = HexEncoder)
        return sha256(val, encoder = HexEncoder)

def parse_program_args(argv):
   inputfile = ''
   outputfile = ''
   try:
      opts, args = getopt.getopt(argv,"hi:o:",["ifile=","ofile="])
   except getopt.GetoptError:
      output('Error in parsing arguments')
      return None
   for opt, arg in opts:
      if opt in ("-i", "--ifile"):
         inputfile = arg
      elif opt in ("-o", "--ofile"):
         outputfile = arg
   return [inputfile, outputfile]

def main():
    # ignore the 1st argument because it will be the program binary path
    if len(sys.argv) < 2:
        output("Incorrect argument count. Must specify the input configuration file atleast")
        return

    [infile, outfile]  = parse_program_args(sys.argv[1:])
    if infile == None:
        output("Must specify input configuration file!")
        sys.exit(2)

    config_dict = read_config.parse_config_file(infile)
    global_config = GlobalConfig(config_dict)
    client_config = ClientConfig(config_dict)
    replica_config = ReplicaConfig(config_dict)

    output("Running BCR simulation for test case: " + global_config.test_case_name)
    request_id_counter = 0
    #client_id, message_number = 1, 10
    #head_timeout, replica_timeout = 3, 3
    olympus = new(Olympus, args=('Olympus', replica_config.num_replica, replica_config.failures, replica_config.head_timeout, replica_config.nonhead_timeout))
    start(olympus)
    #operations = [('put', ['name', 'ankit']), ('get', ['name']), ('append', ['name', 'aggarwal']), ('get', ['name']), ('slice', ['name', 5]), ('get', ['name'])]
    #client_id = 1
    clients = list()

    for i in range(client_config.num_client):
        modified_ops = list(map(lambda o: (o.type.name, o.args_list), client_config.workloads[i]))
        output("Ops are: " + str(modified_ops))
        client = new(Client, args=(i, olympus, request_id_counter, client_config.client_timeout, modified_ops))
        clients.append(client)

    start(clients)
