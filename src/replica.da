from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError

# import for deserialization of message objects
from ast import literal_eval
from time import time
from config import *
import read_config

# Implementation of the Replica process
# The replica process receives Olympus' public key, its timeout value in seconds, and its failure scenarios from Olympus
# in setup
# Failure handling: for each replica, we maintain two dictionaries
#                pending_failures[scenario.action_type] = 1
#                pending_failure_scenarios[scenario.action_type] = scenario
# Key is the scenario action type enum in config.py. This lets us keep track of what scenarios to execute later


class Replica(process):
    ## Replica setup method called from
    def setup(id, name, running_state, replica_failures, replica_timeout, olympus_public_key):
        output_wrapper('replica failures: ' + str(replica_failures))
        self.status = 0  # PENDING
        self.order_proof = list()
        self.result_proof = list()
        self.result_cache = dict()
        self.slot_number = 0
        self.last_slot_number = 0
        self.olympus = None
        self.replicas = None
        self.head = None
        self.tail = None
        self.replica_public_keys = None
        self.private_key = None
        self.client_keys = dict()
        self.configuration = None
        self.pending_failures = {}  # dict of failure_action_type vs boolean
        self.pending_failure_scenarios = {}
        self.messages_received_from_client = {}  # messages received for each client
        self.messages_shuttle = {}  # shuttles received for each client
        self.messages_result_shuttle = {}  # result shuttles received for each client
        self.messages_forwarded_request = {}  # forwarded requests received for each client
        self.ongoing_request_id = None
        self.history = list()

    # Replica starts off in the ACTIVE state. It verifies Olympus and then awaits other messages or Shutdown message.
    def run():
        status = 1  # ACTIVE
        olympus_public_key = VerifyKey(olympus_public_key, encoder=HexEncoder)
        await(received(('Shutdown'), from_=olympus))

    # Replica will shut down if it receives the Shutdown message from Olympus (its waiting in run() will expire)
    def receive(msg=('Immutable'), from_=olympus):
        status = 2  # IMMUTABLE
        output_wrapper(name + ' is now immutable.')

    # Each replica receives its configuration data from Olympus. This happens after replica is created.
    # It gets references to other replicas in chain, head, tail, Olympus, and public keys for other replicas
    def receive(msg=('Configuration', olympus_, replicas_, head_, tail_, config_data)):
        olympus = olympus_
        replicas = replicas_
        head = head_
        tail = tail_
        config_data = verify_data_with_key(config_data, olympus_public_key)
        if config_data is None:
            output_wrapper('Verification of message sent by Olympus has failed.')
            return
        replica_public_keys_, configuration = config_data
        replica_public_keys = [VerifyKey(key, encoder=HexEncoder) for key in replica_public_keys_]
        output_wrapper('{} received replica references and public keys from Olympus'.format(name))
        send(('ACK', name), to=olympus)

    # Replica receives its private key from Olympus, that it uses to sign results and proofs
    def receive(msg=('Key', private_key_), from_=olympus):
        private_key = private_key_
        output_wrapper(name + ' has received its private key from Olympus.')
        send(('ACK', name), to=olympus)

    # Replica receives client public key from Olympus, used to verify client requests
    def receive(msg=('Client_keys', client_id, client_public_key)):
        client_keys[client_id] = VerifyKey(client_public_key, encoder=HexEncoder)
        output_wrapper(
            '{} has received client public key: {} for client {}'.format(name, str(client_public_key), str(client_id)))
        send(('ACK', name), to=olympus)

    # This is a primary message handler for requests for replicas. It handles all possible cases: requests directly
    # from the client, requests from replicas  before in the chain(shuttle)
    def receive(msg=(sender_id, 'Request', type, request_from, client, request_id, client_id, args)):
        output_wrapper(str(type) + ' request with request id ' + str(request_id) + ' received by ' + name + '.')
        if status == 0:
            output_wrapper(name + ' is in PENDING state.')
        elif status == 1:
            output_wrapper(name + ' is in ACTIVE state.')
        elif status == 2:
            output_wrapper(name + ' is in IMMUTABLE state.')

        if status != 1:  # if replica is not ACTIVE
            if request_from == client and status == 2: # IMMUTABLE STATE
                output_wrapper('Sending ERROR message to the client.')
                send((id, 'Operation_result_error', request_id), to=client)
                send(('Operation_result_' + str(request_id)), to=client)
            return

        if ongoing_request_id == request_id:
            output_wrapper('Request with id ' + str(request_id) + ' is already running.')
            return

        ongoing_request_id = request_id
        
        if request_from == client:
            # client_request failure trigger
            if client_id not in messages_received_from_client:
                messages_received_from_client[client_id] = 0
            is_trigger, scenario = check_failure(replica_failures, client_id, messages_received_from_client[client_id],
                                                 FailureType.client_request)
            if is_trigger:
                # mark this failure scenario
                pending_failures[scenario.action_type] = 1
                pending_failure_scenarios[scenario.action_type] = scenario
                output_wrapper(
                    'Replica {}: Trigger client request failure for client_id: {} and message count: {}, scenario: {}'.format(
                        name, client_id, messages_received_from_client[client_id], pending_failures));

            messages_received_from_client[client_id] += 1
            # Verification of digital signature of client
            args = verify_data_with_key(args, client_keys[client_id])
            if args == None:
                output_wrapper('Verification of message sent by Client ' + str(client_id) + ' has failed.')
                return

            if request_id in result_cache:
                sign_and_send(('Operation_result', result_cache[request_id]), client)
                output_wrapper('Result sent from cache of ' + name + '.')
                return
            elif (isinstance(head, set) and self not in head) or (not isinstance(head, set) and self != head):
                sign_and_send(('Request', type, self, client, request_id, client_id, args), head)
                if await(received(('Result_shuttle_' + str(request_id)))):
                    ongoing_request_id = None
                elif timeout(replica_timeout):
                    send(('Reconfiguration', name, configuration), to=olympus)
                return
        else:
            # Verification of digital signature of replicas
            args = verify_data_with_key(args, replica_public_keys[sender_id])
            if args == None:
                output_wrapper('Verification of message sent by Replica ' + str(sender_id) + ' has failed.')
                return

        if (isinstance(head, set) and self in head) or (not isinstance(head, set) and self == head):
            if (isinstance(request_from, set) and client not in request_from) or (not isinstance(request_from, set) and request_from != client):
                # forwarded_request failure trigger
                if client_id not in messages_forwarded_request:
                    messages_forwarded_request[client_id] = 0
                is_trigger, scenario = check_failure(replica_failures, client_id, messages_forwarded_request[client_id],
                                                     FailureType.forwarded_request)
                if is_trigger:
                    # mark this failure scenario
                    pending_failures[scenario.action_type] = 1
                    pending_failure_scenarios[scenario.action_type] = scenario
                    output_wrapper(
                        'Replica {}: Trigger forwarded request failure for client_id: {} and message count: {}, '
                        'scenario: {}'.format(name, client_id, messages_forwarded_request[client_id], scenario))
                messages_forwarded_request[client_id] += 1
            # update running state
            result = update_running_state(type, args)
            slot_number += 1
            # if there is a change_operation failure scenario to execute, do it. Else, proceed as normal.
            if FailureActionType.change_operation in pending_failures and pending_failures[
                FailureActionType.change_operation] == 1:
                stmt_type = 'get'
                stmt_args = ['x']
                output_wrapper('Executing failure scenario: {}'.format(
                    str(pending_failure_scenarios[FailureActionType.change_operation])))
                pending_failures[FailureActionType.change_operation] = 0
                pending_failure_scenarios[FailureActionType.change_operation] = None
            else:
                stmt_type = type
                stmt_args = args
            # generate order statement and order proof
            order_stmt = [[slot_number, (stmt_type, stmt_args), configuration]]  # (type, args) is operation (o)
            order_proof = [slot_number, (type, args), configuration, order_stmt]
            result_proof = [[(type, args), calculate_hash(result)]]  # add result stmt
            shuttle = (order_proof, result_proof)
            history.append(order_proof)
            # sign and send the shuttle (request shuttle) to the next replica in chain
            output_wrapper('Shuttle sent from ' + str(name) + ' to next replica.')
            sign_and_send(('Request', type, self, client, request_id, client_id, shuttle), replicas.get(id + 1))
            last_slot_number = slot_number
            if await(received(('Result_shuttle_' + str(request_id)))):
                ongoing_request_id = None
            elif timeout(replica_timeout):
                output_wrapper(
                    '{} has timed out while waiting for result shuttle for request id {}. Sending reconfiguration '
                    'request to Olympus'.format(
                        name, str(request_id)))
                send(('Reconfiguration', name, configuration), to=olympus)
        else:
            # case of shuttle from some previous replica
            # shuttle failure trigger
            if client_id not in messages_shuttle:
                messages_shuttle[client_id] = 0
            is_trigger, scenario = check_failure(replica_failures, client_id, messages_shuttle[client_id],
                                                 FailureType.shuttle)
            if is_trigger:
                # mark this failure scenario
                pending_failures[scenario.action_type] = 1
                pending_failure_scenarios[scenario.action_type] = scenario
                output_wrapper(
                    'Replica {}: Trigger shuttle failure for client_id: {} and message count: {}, scenario: {}'.format(
                        name, client_id, messages_shuttle[client_id], scenario));
            messages_shuttle[client_id] += 1
            # if the shuttle is invalid, trigger reconfiguration and return
            if not validate_shuttle(args):
                output_wrapper(
                    '{} failed to validate shuttle for request_id: {}. Triggering reconfiguration'.format(name,
                                                                                                          request_id))
                send(('Reconfiguration', name, configuration), to=olympus)
                return

            # unpack arguments
            order_proof, result_proof = args
            slot_number, operation, configuration, order_stmt = order_proof
            last_slot_number = slot_number
            type, operation_args = operation
            # update running state
            result = update_running_state(type, operation_args)
            # if there is a pending change_operation failure scenario to perform, do it.
            if FailureActionType.change_operation in pending_failures and pending_failures[
                FailureActionType.change_operation] == 1:
                output_wrapper('Executing failure scenario: {}'.format(
                    str(pending_failure_scenarios[FailureActionType.change_operation])))
                type = 'get'
                operation_args = ['x']
                pending_failures[FailureActionType.change_operation] = 0
                pending_failure_scenarios[FailureActionType.change_operation] = None
            order_proof[3].append([slot_number, (type, operation_args), configuration])  # append to order_stmt
            result_proof.append([(type, operation_args), calculate_hash(result)])  # append result stmt
            shuttle = (order_proof, result_proof)
            history.append(order_proof)
            # if tail, send result to client. Else, forward result to next replica in chain.
            if (isinstance(tail, set) and self in tail) or (not isinstance(tail, set) and self == tail):
                result_shuttle = [result, result_proof]
                if FailureActionType.change_result in pending_failures and pending_failures[
                    FailureActionType.change_result] == 1:
                    op_t = result_shuttle[1][id][0]
                    result_shuttle[1][id] = [op_t, calculate_hash('OK')]

                if FailureActionType.drop_result_stmt in pending_failures and pending_failures[
                    FailureActionType.drop_result_stmt] == 1:
                    result_t = result_shuttle[0]
                    result_shuttle = [result_t, result_shuttle[1][1:]]

                sign_and_send(('Operation_result', request_id, result_shuttle), client)

                # we send a separate 'Operation_result_' message to client for tracking the completion of a
                # particular request with this request_id. It is not possible for the client to wait for specific
                # requests in any other way.
                send(('Operation_result_' + str(request_id)), to=client)

                # The tail sends a result_shuttle message to itself to initiate the result shuttle handler train
                sign_and_send(('Result_shuttle', self, request_id, client_id, result_shuttle), tail)
            else:
                output_wrapper('Shuttle sent from ' + str(name) + ' to next replica.')
                sign_and_send(('Request', type, self, client, request_id, client_id, shuttle), replicas.get(id + 1))
                if await(received(('Result_shuttle_' + str(request_id)))):
                    ongoing_request_id = None
                elif timeout(replica_timeout):
                    send(('Reconfiguration', name, configuration), to=olympus)

    # message handler for Result shuttle message received from the next replica in chain

    def receive(msg=(sender_id, 'Result_shuttle', request_from, request_id, client_id, result_shuttle)):
        # mark result_shuttle failure trigger
        if client_id not in messages_result_shuttle:
            messages_result_shuttle[client_id] = 0
        is_trigger, scenario = check_failure(replica_failures, client_id, messages_result_shuttle[client_id],
                                             FailureType.result_shuttle)
        if is_trigger:
            # mark this failure scenario
            pending_failures[scenario.action_type] = 1
            pending_failure_scenarios[scenario.action_type] = scenario
            output_wrapper(
                '{}: Trigger result shuttle failure for client_id: {} and message count: {}, scenario: {}'.format(name,
                                                                                                                  client_id,
                                                                                                                  messages_result_shuttle[
                                                                                                                      client_id],
                                                                                                                  scenario))
        messages_result_shuttle[client_id] += 1

        # Verification of signature of replicas sending result shuttles
        result_shuttle = verify_data_with_key(result_shuttle, replica_public_keys[sender_id])
        if result_shuttle == None:
            output_wrapper('Verification of message sent by Replica ' + str(sender_id) + ' has failed.')
            return

        if validate_result_shuttle(result_shuttle):
            result_cache[request_id] = result_shuttle
            if (isinstance(head, set) and self not in head) or (not isinstance(head, set) and self != head):
                if FailureActionType.change_result in pending_failures and pending_failures[FailureActionType.change_result] == 1:
                    output_wrapper('Executing failure scenario: {}'.format(
                        str(pending_failure_scenarios[FailureActionType.change_result])))
                    op_t = result_shuttle[1][id][0]
                    result_shuttle[1][id] = [op_t, calculate_hash('OK')]
                    pending_failures[FailureActionType.change_result] = 0
                    pending_failure_scenarios[FailureActionType.change_result] = None
                if FailureActionType.drop_result_stmt in pending_failures and pending_failures[
                    FailureActionType.drop_result_stmt] == 1:
                    output_wrapper('Executing failure scenario: {}'.format(
                        str(pending_failure_scenarios[FailureActionType.drop_result_stmt])))
                    result_t = result_shuttle[0]
                    result_shuttle = [result_t, result_shuttle[1][1:]]
                    pending_failures[FailureActionType.drop_result_stmt] = 0
                    pending_failure_scenarios[FailureActionType.drop_result_stmt] = None
                sign_and_send(('Result_shuttle', self, request_id, client_id, result_shuttle), replicas.get(id - 1))
                send(('Result_shuttle_' + str(request_id)), to=replicas.get(id - 1))
            output_wrapper('Result shuttle is at ' + str(name) + '.')
        else:
            output_wrapper('Result shuttle sent by Replica ' + str(sender_id) + ' is not valid.')
            send(('Reconfiguration', name, configuration), to=olympus)

    # wedge statement received from olympus!
    # TODO check that it is Olympus' public key!
    def receive(msg=('wedge_request'), from_=olympus):
        status = 2 # IMMUTABLE
        output_wrapper('Received wedge request from Olympus')
        send(('wedge', history, id), to=olympus)

    # catch up statement received from olympus!
    # TODO check that it is Olympus' public key!
    def receive(msg=('catch_up', gap), from_=olympus):
        for op_to_apply in gap:
            update_running_state(op_to_apply[1][0], op_to_apply[1][1])
        send(('caught_up', calculate_hash(running_state), id), to=olympus)

    # get_running_state from olympus
    def receive(msg=('get_running_state'), from_=olympus):
        output_wrapper('Response to get_running_state sent to Olympus by ' + str(name) + '.')
        send(('response_get_running_state', id, running_state), to=olympus)

    # method to update running state in replica. It performs one out of 4 supported operations.
    def update_running_state(type, args):
        if type == 'put':
            if len(args) > 1:
                running_state[args[0]] = args[1]
            return 'OK'
        elif type == 'get':
            if len(args) > 0:
                if args[0] in running_state:
                    return running_state[args[0]]
                else:
                    return ''
        elif type == 'slice':
            if len(args) > 1:
                lower, upper = map(int, args[1].split(':'))
                if args[0] in running_state and lower >= 0 and upper <= len(running_state[args[0]]):
                    running_state[args[0]] = running_state[args[0]][lower:upper]
                    return running_state[args[0]]
                else:
                    return 'fail'
        elif type == 'append':
            if len(args) > 1:
                if args[0] in running_state:
                    running_state[args[0]] = running_state[args[0]] + args[1]
                    return 'OK'
                else:
                    return 'fail'

    # calculate the sha256 hash of value
    def calculate_hash(val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        elif isinstance(val, dict):
            return sha256(str.encode(str(val)), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    # validate the shuttle coming from previous replica
    def validate_shuttle(shuttle):
        order_proof, result_proof = shuttle
        slot_number, operation, configuration, order_stmt = order_proof
        if last_slot_number != slot_number - 1:
            return False
        for stmt in order_stmt:
            if stmt[0] != slot_number or stmt[1] != operation or stmt[2] != configuration:
                return False
        return True

    # validate the result shuttle coming back from next replica
    def validate_result_shuttle(result_shuttle):
        result, result_proof = result_shuttle
        if len(result_proof) != len(replicas):
            return False
        hash = calculate_hash(result)
        for i in result_proof:
            if hash != i[1]:
                return False
        return True

    # encrypt data with own private key and send
    def sign_and_send(data, to_):
        data = [id] + list(data)
        data[-1] = private_key.sign(str(data[-1]).encode('utf-8'))
        send(tuple(data), to=to_)

    # verify data with own public key and parse it
    def verify_data_with_key(data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    # method that checks if a failure scenario is applicable with current parameters
    # if it is, the caller will update the current failure scenario dicts accordingly

    def check_failure(replica_failures, source_id, source_message_count, required_type):
        for i, failure in enumerate(replica_failures):
            oper = failure.operands
            if failure.failure_type == required_type and source_id == oper[0] and source_message_count == oper[1]:
                return (True, failure)

        return (False, None)

    # Utility method for logging, prepends process name and time to each log statement
    def output_wrapper(log):
        output('[{}][TS: {}]'.format(name, str(time())), log)