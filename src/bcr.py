# -*- generated by 1.0.9 -*-
import da
PatternExpr_362 = da.pat.ConstantPattern('Shutdown')
PatternExpr_366 = da.pat.BoundPattern('_BoundPattern367_')
PatternExpr_380 = da.pat.ConstantPattern('Shutdown')
PatternExpr_384 = da.pat.FreePattern('olympus')
PatternExpr_398 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.FreePattern('olympus_'), da.pat.FreePattern('replicas_'), da.pat.FreePattern('head_'), da.pat.FreePattern('tail_'), da.pat.FreePattern('config_data')])
PatternExpr_472 = da.pat.TuplePattern([da.pat.ConstantPattern('Key'), da.pat.FreePattern('private_key_')])
PatternExpr_479 = da.pat.FreePattern('olympus')
PatternExpr_499 = da.pat.TuplePattern([da.pat.ConstantPattern('Client_keys'), da.pat.FreePattern('client_id'), da.pat.FreePattern('client_public_key')])
PatternExpr_537 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Request'), da.pat.FreePattern('type'), da.pat.FreePattern('request_from'), da.pat.FreePattern('client'), da.pat.FreePattern('request_id'), da.pat.FreePattern('client_id'), da.pat.FreePattern('args')])
PatternExpr_740 = da.pat.BoundPattern('_BoundPattern746_')
PatternExpr_976 = da.pat.BoundPattern('_BoundPattern982_')
PatternExpr_1306 = da.pat.BoundPattern('_BoundPattern1312_')
PatternExpr_1338 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Result_shuttle'), da.pat.FreePattern('request_from'), da.pat.FreePattern('request_id'), da.pat.FreePattern('client_id'), da.pat.FreePattern('result_shuttle')])
PatternExpr_368 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern374_')]), da.pat.ConstantPattern('Shutdown')])
PatternExpr_748 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern755_')])
PatternExpr_984 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern991_')])
PatternExpr_1314 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern1321_')])
PatternExpr_2208 = da.pat.TuplePattern([da.pat.ConstantPattern('ACK'), da.pat.FreePattern('sender')])
PatternExpr_2227 = da.pat.TuplePattern([da.pat.ConstantPattern('Get_configuration'), da.pat.FreePattern('client'), da.pat.FreePattern('client_name'), da.pat.FreePattern('client_id'), da.pat.FreePattern('client_public_key')])
PatternExpr_2293 = da.pat.TuplePattern([da.pat.ConstantPattern('Reconfiguration'), da.pat.FreePattern('sender'), da.pat.FreePattern('proof_of_misbehavior')])
PatternExpr_2409 = da.pat.TuplePattern([da.pat.ConstantPattern('ACK'), da.pat.ConstantPattern(None)])
PatternExpr_2432 = da.pat.ConstantPattern('Shutdown')
PatternExpr_2416 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('ACK'), da.pat.ConstantPattern(None)])])
PatternExpr_2436 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Shutdown')])
PatternExpr_2549 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.FreePattern('replicas_'), da.pat.FreePattern('head_')])
PatternExpr_2558 = da.pat.FreePattern('olympus')
PatternExpr_2581 = da.pat.TuplePattern([da.pat.ConstantPattern('Keys'), da.pat.FreePattern('replica_public_keys_'), da.pat.FreePattern('olympus_public_key_')])
PatternExpr_2590 = da.pat.FreePattern('olympus')
PatternExpr_2626 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Operation_result'), da.pat.FreePattern('request_id'), da.pat.FreePattern('result_shuttle')])
PatternExpr_2807 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern2810_'), da.pat.BoundPattern('_BoundPattern2811_')])
PatternExpr_2861 = da.pat.BoundPattern('_BoundPattern2867_')
PatternExpr_2933 = da.pat.ConstantPattern('Shutdown')
PatternExpr_2814 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.BoundPattern('_BoundPattern2824_'), da.pat.BoundPattern('_BoundPattern2825_')])])
PatternExpr_2869 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern2876_')])
PatternExpr_2937 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('Shutdown')])
_config_object = {'channel': {'reliable', 'fifo'}}
from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey
from nacl.exceptions import BadSignatureError
from ast import literal_eval
from config import *
import read_config
import sys
import getopt
from time import time

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_0 = []
        self._ReplicaReceivedEvent_6 = []
        self._ReplicaReceivedEvent_7 = []
        self._ReplicaReceivedEvent_8 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_362, sources=[PatternExpr_366], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_380, sources=[PatternExpr_384], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_379]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_398, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_397]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_472, sources=[PatternExpr_479], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_471]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_499, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_498]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_537, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_536]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_740, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_976, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_1306, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_1338, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1337])])

    def setup(self, id, name, replica_failures, replica_timeout, olympus_public_key, **rest_3522):
        super().setup(id=id, name=name, replica_failures=replica_failures, replica_timeout=replica_timeout, olympus_public_key=olympus_public_key, **rest_3522)
        self._state.id = id
        self._state.name = name
        self._state.replica_failures = replica_failures
        self._state.replica_timeout = replica_timeout
        self._state.olympus_public_key = olympus_public_key
        self.output_wrapper(('replica failures: ' + str(self._state.replica_failures)))
        self._state.status = 0
        self._state.running_state = dict()
        self._state.order_proof = list()
        self._state.result_proof = list()
        self._state.result_cache = dict()
        self._state.slot_number = 0
        self._state.last_slot_number = 0
        self._state.olympus = None
        self._state.replicas = None
        self._state.head = None
        self._state.tail = None
        self._state.replica_public_keys = None
        self._state.private_key = None
        self._state.client_keys = dict()
        self._state.configuration = None
        self._state.pending_failures = {}
        self._state.pending_failure_scenarios = {}
        self._state.messages_received_from_client = {}
        self._state.messages_shuttle = {}
        self._state.messages_result_shuttle = {}
        self._state.messages_forwarded_request = {}

    def run(self):
        self._state.status = 1
        self._state.olympus_public_key = VerifyKey(self._state.olympus_public_key, encoder=HexEncoder)
        super()._label('_st_label_359', block=False)
        _st_label_359 = 0
        while (_st_label_359 == 0):
            _st_label_359 += 1
            if PatternExpr_368.match_iter(self._ReplicaReceivedEvent_0, _BoundPattern374_=self._state.olympus, SELF_ID=self._id):
                _st_label_359 += 1
            else:
                super()._label('_st_label_359', block=True)
                _st_label_359 -= 1

    def update_running_state(self, type, args):
        if (type == 'put'):
            if (len(args) > 1):
                self._state.running_state[args[0]] = args[1]
            return 'OK'
        elif (type == 'get'):
            if (len(args) > 0):
                if (args[0] in self._state.running_state):
                    return self._state.running_state[args[0]]
                else:
                    return ''
        elif (type == 'slice'):
            if (len(args) > 1):
                (lower, upper) = map(int, args[1].split(':'))
                if ((args[0] in self._state.running_state) and (lower >= 0) and (upper <= len(self._state.running_state[args[0]]))):
                    self._state.running_state[args[0]] = self._state.running_state[args[0]][lower:upper]
                    return self._state.running_state[args[0]]
                else:
                    return 'fail'
        elif (type == 'append'):
            if (len(args) > 1):
                if (args[0] in self._state.running_state):
                    self._state.running_state[args[0]] = (self._state.running_state[args[0]] + args[1])
                    return 'OK'
                else:
                    return 'fail'

    def calculate_hash(self, val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    def validate_shuttle(self, shuttle):
        (self._state.order_proof, self._state.result_proof) = shuttle
        (self._state.slot_number, operation, self._state.configuration, order_stmt) = self._state.order_proof
        if (not (self._state.last_slot_number == (self._state.slot_number - 1))):
            return False
        for stmt in order_stmt:
            if ((not (stmt[0] == self._state.slot_number)) or (not (stmt[1] == operation)) or (not (stmt[2] == self._state.configuration))):
                return False
        return True

    def validate_result_shuttle(self, result_shuttle):
        (result, self._state.result_proof) = result_shuttle
        if (not (len(self._state.result_proof) == len(self._state.replicas))):
            return False
        hash = self.calculate_hash(result)
        for i in self._state.result_proof:
            if (not (hash == i[1])):
                return False
        return True

    def sign_and_send(self, data, to_):
        data = ([self._state.id] + list(data))
        data[(- 1)] = self._state.private_key.sign(str(data[(- 1)]).encode('utf-8'))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def check_failure(self, replica_failures, source_id, source_message_count, required_type):
        for (i, failure) in enumerate(replica_failures):
            oper = failure.operands
            if ((failure.failure_type == required_type) and (source_id == oper[0]) and (source_message_count == oper[1])):
                return (True, failure)
        return (False, None)

    def output_wrapper(self, log):
        self.output('[{}][TS: {}]'.format(self._state.name, str(time())), log)

    def _Replica_handler_379(self, olympus):
        self._state.status = 2
        self.output_wrapper((self._state.name + ' is immutable and shutting down.'))
    _Replica_handler_379._labels = None
    _Replica_handler_379._notlabels = None

    def _Replica_handler_397(self, olympus_, replicas_, head_, tail_, config_data):
        self._state.olympus = olympus_
        self._state.replicas = replicas_
        self._state.head = head_
        self._state.tail = tail_
        config_data = self.verify_data_with_key(config_data, self._state.olympus_public_key)
        if (config_data == None):
            self.output_wrapper('Verification of message sent by Olympus has failed.')
            return
        (replica_public_keys_, self._state.configuration) = config_data
        self._state.replica_public_keys = [VerifyKey(key, encoder=HexEncoder) for key in replica_public_keys_]
        self.output_wrapper('{} received replica references and public keys from Olympus'.format(self._state.name))
        self.send(('ACK', self._state.name), to=self._state.olympus)
    _Replica_handler_397._labels = None
    _Replica_handler_397._notlabels = None

    def _Replica_handler_471(self, private_key_, olympus):
        self._state.private_key = private_key_
        self.output_wrapper((self._state.name + ' has receives its private key from Olympus.'))
        self.send(('ACK', self._state.name), to=olympus)
    _Replica_handler_471._labels = None
    _Replica_handler_471._notlabels = None

    def _Replica_handler_498(self, client_id, client_public_key):
        self._state.client_keys[client_id] = VerifyKey(client_public_key, encoder=HexEncoder)
        self.output_wrapper('{} has received client public key: {} for client {}'.format(self._state.name, str(client_public_key), str(client_id)))
        self.send(('ACK', self._state.name), to=self._state.olympus)
    _Replica_handler_498._labels = None
    _Replica_handler_498._notlabels = None

    def _Replica_handler_536(self, sender_id, type, request_from, client, request_id, client_id, args):
        self.output_wrapper((((((str(type) + ' request with request id ') + str(request_id)) + ' received by ') + self._state.name) + '.'))
        if (self._state.status == 0):
            self.output_wrapper((self._state.name + ' is in PENDING state.'))
        elif (self._state.status == 1):
            self.output_wrapper((self._state.name + ' is in ACTIVE state.'))
        elif (self._state.status == 2):
            self.output_wrapper((self._state.name + ' is in IMMUTABLE state.'))
        if (not (self._state.status == 1)):
            self.output_wrapper('Replica is not in ACTIVE state. Not handling message')
            return
        if (request_from == client):
            if (not (client_id in self._state.messages_received_from_client)):
                self._state.messages_received_from_client[client_id] = 0
            (is_trigger, scenario) = self.check_failure(self._state.replica_failures, client_id, self._state.messages_received_from_client[client_id], FailureType.client_request)
            if is_trigger:
                self._state.pending_failures[scenario.action_type] = 1
                self._state.pending_failure_scenarios[scenario.action_type] = scenario
                self.output_wrapper('Replica {}: Trigger client request failure for client_id: {} and message count: {}, scenario: {}'.format(self._state.name, client_id, self._state.messages_received_from_client[client_id], self._state.pending_failures))
            self._state.messages_received_from_client[client_id] += 1
            args = self.verify_data_with_key(args, self._state.client_keys[client_id])
            if (args == None):
                self.output_wrapper((('Verification of message sent by Client ' + str(client_id)) + ' has failed.'))
                return
            if (request_id in self._state.result_cache):
                self.sign_and_send(('Operation_result', self._state.result_cache[request_id]), client)
                self.output_wrapper((('Result sent from cache of ' + self._state.name) + '.'))
                return
            elif (not (self._id == self._state.head)):
                self.sign_and_send(('Request', type, self._id, client, request_id, client_id, args), self._state.head)
                super()._label('_st_label_737', block=False)
                _st_label_737 = 0
                self._timer_start()
                while (_st_label_737 == 0):
                    _st_label_737 += 1
                    if PatternExpr_748.match_iter(self._ReplicaReceivedEvent_6, _BoundPattern755_=('Result_shuttle_' + str(request_id)), SELF_ID=self._id):
                        pass
                        _st_label_737 += 1
                    elif self._timer_expired:
                        self.send(('Reconfiguration', self._state.name, None), to=self._state.olympus)
                        _st_label_737 += 1
                    else:
                        super()._label('_st_label_737', block=True, timeout=self._state.replica_timeout)
                        _st_label_737 -= 1
                return
        else:
            args = self.verify_data_with_key(args, self._state.replica_public_keys[sender_id])
            if (args == None):
                self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed.'))
                return
        if (self._id == self._state.head):
            if (not (request_from == client)):
                if (not (client_id in self._state.messages_forwarded_request)):
                    self._state.messages_forwarded_request[client_id] = 0
                (is_trigger, scenario) = self.check_failure(self._state.replica_failures, client_id, self._state.messages_forwarded_request[client_id], FailureType.forwarded_request)
                if is_trigger:
                    self._state.pending_failures[scenario.action_type] = 1
                    self._state.pending_failure_scenarios[scenario.action_type] = scenario
                    self.output_wrapper('Replica {}: Trigger forwarded request failure for client_id: {} and message count: {}, scenario: {}'.format(self._state.name, client_id, self._state.messages_forwarded_request[client_id], scenario))
                self._state.messages_forwarded_request[client_id] += 1
            result = self.update_running_state(type, args)
            self._state.slot_number += 1
            if ((FailureActionType.change_operation in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.change_operation] == 1)):
                stmt_type = 'get'
                stmt_args = ['x']
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.change_operation])))
                self._state.pending_failures[FailureActionType.change_operation] = 0
                self._state.pending_failure_scenarios[FailureActionType.change_operation] = None
            else:
                stmt_type = type
                stmt_args = args
            order_stmt = [[self._state.slot_number, (stmt_type, stmt_args), self._state.configuration]]
            self._state.order_proof = [self._state.slot_number, (type, args), self._state.configuration, order_stmt]
            self._state.result_proof = [[(type, args), self.calculate_hash(result)]]
            shuttle = (self._state.order_proof, self._state.result_proof)
            self.sign_and_send(('Request', type, self._id, client, request_id, client_id, shuttle), self._state.replicas[(self._state.id + 1)])
            self._state.last_slot_number = self._state.slot_number
            super()._label('_st_label_973', block=False)
            _st_label_973 = 0
            self._timer_start()
            while (_st_label_973 == 0):
                _st_label_973 += 1
                if PatternExpr_984.match_iter(self._ReplicaReceivedEvent_7, _BoundPattern991_=('Result_shuttle_' + str(request_id)), SELF_ID=self._id):
                    pass
                    _st_label_973 += 1
                elif self._timer_expired:
                    self.output_wrapper('{} has timed out while waiting for result shuttle for request id {}. Sending reconfiguration request to Olympus'.format(self._state.name, str(request_id)))
                    self.send(('Reconfiguration', self._state.name, None), to=self._state.olympus)
                    _st_label_973 += 1
                else:
                    super()._label('_st_label_973', block=True, timeout=self._state.replica_timeout)
                    _st_label_973 -= 1
        else:
            if (not (client_id in self._state.messages_shuttle)):
                self._state.messages_shuttle[client_id] = 0
            (is_trigger, scenario) = self.check_failure(self._state.replica_failures, client_id, self._state.messages_shuttle[client_id], FailureType.shuttle)
            if is_trigger:
                self._state.pending_failures[scenario.action_type] = 1
                self._state.pending_failure_scenarios[scenario.action_type] = scenario
                self.output_wrapper('Replica {}: Trigger shuttle failure for client_id: {} and message count: {}, scenario: {}'.format(self._state.name, client_id, self._state.messages_shuttle[client_id], scenario))
            self._state.messages_shuttle[client_id] += 1
            if (not self.validate_shuttle(args)):
                self.output_wrapper('{} failed to validate shuttle for request_id: {}. Triggering reconfiguration'.format(self._state.name, request_id))
                self.send(('Reconfiguration', self._state.name, None), to=self._state.olympus)
                return
            (self._state.order_proof, self._state.result_proof) = args
            (self._state.slot_number, operation, self._state.configuration, order_stmt) = self._state.order_proof
            self._state.last_slot_number = self._state.slot_number
            (type, operation_args) = operation
            result = self.update_running_state(type, operation_args)
            if ((FailureActionType.change_operation in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.change_operation] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.change_operation])))
                type = 'get'
                operation_args = ['x']
                self._state.pending_failures[FailureActionType.change_operation] = 0
                self._state.pending_failure_scenarios[FailureActionType.change_operation] = None
            self._state.order_proof[3].append([self._state.slot_number, (type, operation_args), self._state.configuration])
            self._state.result_proof.append([(type, operation_args), self.calculate_hash(result)])
            shuttle = (self._state.order_proof, self._state.result_proof)
            if (self._id == self._state.tail):
                result_shuttle = [result, self._state.result_proof]
                if ((FailureActionType.change_result in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.change_result] == 1)):
                    op_t = result_shuttle[1][self._state.id][0]
                    result_shuttle[1][self._state.id] = [op_t, self.calculate_hash('OK')]
                if ((FailureActionType.drop_result_stmt in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.drop_result_stmt] == 1)):
                    result_t = result_shuttle[0]
                    result_shuttle = [result_t, result_shuttle[1][1:]]
                self.sign_and_send(('Operation_result', request_id, result_shuttle), client)
                self.send(('Operation_result_' + str(request_id)), to=client)
                self.sign_and_send(('Result_shuttle', self._id, request_id, client_id, result_shuttle), self._state.tail)
            else:
                self.sign_and_send(('Request', type, self._id, client, request_id, client_id, shuttle), self._state.replicas[(self._state.id + 1)])
                super()._label('_st_label_1303', block=False)
                _st_label_1303 = 0
                self._timer_start()
                while (_st_label_1303 == 0):
                    _st_label_1303 += 1
                    if PatternExpr_1314.match_iter(self._ReplicaReceivedEvent_8, _BoundPattern1321_=('Result_shuttle_' + str(request_id)), SELF_ID=self._id):
                        pass
                        _st_label_1303 += 1
                    elif self._timer_expired:
                        self.send(('Reconfiguration', self._state.name, None), to=self._state.olympus)
                        _st_label_1303 += 1
                    else:
                        super()._label('_st_label_1303', block=True, timeout=self._state.replica_timeout)
                        _st_label_1303 -= 1
    _Replica_handler_536._labels = None
    _Replica_handler_536._notlabels = None

    def _Replica_handler_1337(self, sender_id, request_from, request_id, client_id, result_shuttle):
        if (not (client_id in self._state.messages_result_shuttle)):
            self._state.messages_result_shuttle[client_id] = 0
        (is_trigger, scenario) = self.check_failure(self._state.replica_failures, client_id, self._state.messages_result_shuttle[client_id], FailureType.result_shuttle)
        if is_trigger:
            self._state.pending_failures[scenario.action_type] = 1
            self._state.pending_failure_scenarios[scenario.action_type] = scenario
            self.output_wrapper('{}: Trigger result shuttle failure for client_id: {} and message count: {}, scenario: {}'.format(self._state.name, client_id, self._state.messages_result_shuttle[client_id], scenario))
        self._state.messages_result_shuttle[client_id] += 1
        result_shuttle = self.verify_data_with_key(result_shuttle, self._state.replica_public_keys[sender_id])
        if (result_shuttle == None):
            self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed.'))
            return
        if self.validate_result_shuttle(result_shuttle):
            self._state.result_cache[request_id] = result_shuttle
            if (not (self._id == self._state.head)):
                if ((FailureActionType.change_result in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.change_result] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.change_result])))
                    op_t = result_shuttle[1][self._state.id][0]
                    result_shuttle[1][self._state.id] = [op_t, self.calculate_hash('OK')]
                    self._state.pending_failures[FailureActionType.change_result] = 0
                    self._state.pending_failure_scenarios[FailureActionType.change_result] = None
                if ((FailureActionType.drop_result_stmt in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.drop_result_stmt] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.drop_result_stmt])))
                    result_t = result_shuttle[0]
                    result_shuttle = [result_t, result_shuttle[1][1:]]
                    self._state.pending_failures[FailureActionType.drop_result_stmt] = 0
                    self._state.pending_failure_scenarios[FailureActionType.drop_result_stmt] = None
                self.sign_and_send(('Result_shuttle', self._id, request_id, client_id, result_shuttle), self._state.replicas[(self._state.id - 1)])
                self.send(('Result_shuttle_' + str(request_id)), to=self._state.replicas[(self._state.id - 1)])
            self.output_wrapper((('Result shuttle is at ' + str(self._state.name)) + '.'))
        else:
            self.output_wrapper((('Result shuttle sent by Replica ' + str(sender_id)) + ' is not valid.'))
            self.send(('Reconfiguration', self._state.name, None), to=self._state.olympus)
    _Replica_handler_1337._labels = None
    _Replica_handler_1337._notlabels = None

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._OlympusReceivedEvent_3 = []
        self._OlympusReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_2208, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_2207]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_1', PatternExpr_2227, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_2226]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_2', PatternExpr_2293, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_2292]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_3', PatternExpr_2409, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_4', PatternExpr_2432, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, name, num_replicas, all_replica_conf_failures, head_timeout, replica_timeout, **rest_3522):
        super().setup(name=name, num_replicas=num_replicas, all_replica_conf_failures=all_replica_conf_failures, head_timeout=head_timeout, replica_timeout=replica_timeout, **rest_3522)
        self._state.name = name
        self._state.num_replicas = num_replicas
        self._state.all_replica_conf_failures = all_replica_conf_failures
        self._state.head_timeout = head_timeout
        self._state.replica_timeout = replica_timeout
        self._state.replicas = list()
        self._state.replica_private_keys = list()
        self._state.replica_public_keys = list()
        self._state.head = None
        self._state.tail = None
        self._state.private_key = SigningKey.generate()
        self._state.public_key = self._state.private_key.verify_key.encode(encoder=HexEncoder)
        self._state.configuration_number = 0
        self._state.client_keys = {}
        all_replica_failures = self._state.all_replica_conf_failures.get(self._state.configuration_number, {})
        for i in range(self._state.num_replicas):
            replica_failures = all_replica_failures.get(i, {})
            if (i == 0):
                replica = self.new(Replica, args=(i, 'Head', replica_failures, self._state.head_timeout, self._state.public_key))
                self._state.head = replica
            elif (i == (self._state.num_replicas - 1)):
                replica = self.new(Replica, args=(i, 'Tail', replica_failures, self._state.replica_timeout, self._state.public_key))
                self._state.tail = replica
            else:
                replica = self.new(Replica, args=(i, ('Replica ' + str(i)), replica_failures, self._state.replica_timeout, self._state.public_key))
            self._state.replicas.append(replica)
            replica_name = ('Replica ' + str(i))
            self.output_wrapper('Olympus created replica process: {}'.format(replica_name))
            signing_key = SigningKey.generate()
            verify_key = signing_key.verify_key.encode(encoder=HexEncoder)
            self.output_wrapper('Olympus created keys for replica process: {}. Public key: {}'.format(replica_name, str(verify_key)))
            self._state.replica_private_keys.append(signing_key)
            self._state.replica_public_keys.append(verify_key)

    def run(self):
        self._start(self._state.replicas)
        self.sign_and_send(('Configuration', self._id, self._state.replicas, self._state.head, self._state.tail, [self._state.replica_public_keys, self._state.configuration_number]), self._state.replicas)
        for i in range(len(self._state.replicas)):
            self.send(('Key', self._state.replica_private_keys[i]), to=self._state.replicas[i])
        super()._label('_st_label_2406', block=False)
        _st_label_2406 = 0
        while (_st_label_2406 == 0):
            _st_label_2406 += 1
            if PatternExpr_2416.match_iter(self._OlympusReceivedEvent_3, SELF_ID=self._id):
                _st_label_2406 += 1
            else:
                super()._label('_st_label_2406', block=True)
                _st_label_2406 -= 1
        super()._label('_st_label_2429', block=False)
        _st_label_2429 = 0
        while (_st_label_2429 == 0):
            _st_label_2429 += 1
            if PatternExpr_2436.match_iter(self._OlympusReceivedEvent_4, SELF_ID=self._id):
                _st_label_2429 += 1
            else:
                super()._label('_st_label_2429', block=True)
                _st_label_2429 -= 1

    def sign_and_send(self, data, to_):
        data = list(data)
        data[(- 1)] = self._state.private_key.sign(str(data[(- 1)]).encode('utf-8'))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def output_wrapper(self, log):
        self.output('[{}][TS: {}]'.format(self._state.name, str(time())), log)

    def _Olympus_handler_2207(self, sender):
        self.output_wrapper((('ACK from ' + str(sender)) + '.'))
    _Olympus_handler_2207._labels = None
    _Olympus_handler_2207._notlabels = None

    def _Olympus_handler_2226(self, client, client_name, client_id, client_public_key):
        self._state.client_keys[client_id] = VerifyKey(client_public_key, encoder=HexEncoder)
        self.send(('Configuration', self._state.replicas, self._state.head), to=client)
        self.send(('Keys', self._state.replica_public_keys, self._state.public_key), to=client)
        self.send(('Client_keys', client_id, client_public_key), to=self._state.replicas)
        self.output_wrapper('Received public key: {} from client: {}'.format(str(client_public_key), str(client_name)))
        self.output_wrapper((('Configuration sent to ' + str(client_name)) + '.'))
    _Olympus_handler_2226._labels = None
    _Olympus_handler_2226._notlabels = None

    def _Olympus_handler_2292(self, sender, proof_of_misbehavior):
        self.output_wrapper((('Reconfiguration request received from ' + str(sender)) + '.'))
        self.output_wrapper('No reconfiguration mechanism implemented yet.')
    _Olympus_handler_2292._labels = None
    _Olympus_handler_2292._notlabels = None

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_3 = []
        self._ClientReceivedEvent_4 = []
        self._ClientReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_2549, sources=[PatternExpr_2558], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2548]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_2581, sources=[PatternExpr_2590], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2580]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_2626, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2625]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_2807, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_2861, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_2933, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, client_id, olympus, request_id, client_timeout, operations, num_failures, **rest_3522):
        super().setup(client_id=client_id, olympus=olympus, request_id=request_id, client_timeout=client_timeout, operations=operations, num_failures=num_failures, **rest_3522)
        self._state.client_id = client_id
        self._state.olympus = olympus
        self._state.request_id = request_id
        self._state.client_timeout = client_timeout
        self._state.operations = operations
        self._state.num_failures = num_failures
        self._state.name = ('Client ' + str(self._state.client_id))
        self._state.replicas = None
        self._state.head = None
        self._state.replica_public_keys = None
        self._state.olympus_public_key = None
        self._state.private_key = SigningKey.generate()
        self._state.public_key = self._state.private_key.verify_key.encode(encoder=HexEncoder)
        self._state.client_running_state = dict()
        self._state.client_running_state_sync = dict()

    def run(self):
        if (self._state.replicas is None):
            self.send(('Get_configuration', self._id, self._state.name, self._state.client_id, self._state.public_key), to=self._state.olympus)
            super()._label('_st_label_2804', block=False)
            _st_label_2804 = 0
            while (_st_label_2804 == 0):
                _st_label_2804 += 1
                if PatternExpr_2814.match_iter(self._ClientReceivedEvent_3, _BoundPattern2824_=self._state.replicas, _BoundPattern2825_=self._state.head, SELF_ID=self._id):
                    _st_label_2804 += 1
                else:
                    super()._label('_st_label_2804', block=True)
                    _st_label_2804 -= 1
        for op in self._state.operations:
            self.update_client_running_state(self._state.client_running_state, op[0], op[1])
            retry = 0
            while True:
                self.send_request(op[0], op[1], retry)
                super()._label('_st_label_2858', block=False)
                _st_label_2858 = 0
                self._timer_start()
                while (_st_label_2858 == 0):
                    _st_label_2858 += 1
                    if PatternExpr_2869.match_iter(self._ClientReceivedEvent_4, _BoundPattern2876_=('Operation_result_' + str(self._state.request_id)), SELF_ID=self._id):
                        break
                        _st_label_2858 += 1
                    elif self._timer_expired:
                        self.output_wrapper('Timeout: Retrying request id: {}, sending to all replicas'.format(str(self._state.request_id)))
                        retry = 1
                        _st_label_2858 += 1
                    else:
                        super()._label('_st_label_2858', block=True, timeout=self._state.client_timeout)
                        _st_label_2858 -= 1
                else:
                    if (_st_label_2858 != 2):
                        continue
                if (_st_label_2858 != 2):
                    break
        self.output_wrapper((('Local running state of client after the given set of operations: ' + str(self._state.client_running_state)) + '.'))
        self.output_wrapper((('Running state of client at the server (assuming no conflicting keys from other clients) after the given set of operations: ' + str(self._state.client_running_state_sync)) + '.'))
        if are_dicts_equal(self._state.client_running_state, self._state.client_running_state_sync):
            self.output_wrapper('\n\nTest case passed! Actual and expected running states match.\n\n')
        else:
            self.output_wrapper("\n\nTest case failed! Actual and expected running states don't match\n\n")
        super()._label('_st_label_2930', block=False)
        _st_label_2930 = 0
        while (_st_label_2930 == 0):
            _st_label_2930 += 1
            if PatternExpr_2937.match_iter(self._ClientReceivedEvent_5, SELF_ID=self._id):
                _st_label_2930 += 1
            else:
                super()._label('_st_label_2930', block=True)
                _st_label_2930 -= 1

    def sign_and_send(self, data, to_):
        data = list(data)
        data[(- 1)] = self._state.private_key.sign(str(data[(- 1)]).encode('utf-8'))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return literal_eval(data.message.decode('utf-8'))
        except BadSignatureError:
            return None

    def update_client_running_state(self, running_state, type, args):
        if (type == 'put'):
            if (len(args) > 1):
                running_state[args[0]] = args[1]
            return 'OK'
        elif (type == 'get'):
            if (len(args) > 0):
                if (args[0] in running_state):
                    return running_state[args[0]]
                else:
                    return ''
        elif (type == 'slice'):
            if (len(args) > 1):
                (lower, upper) = map(int, args[1].split(':'))
                if ((args[0] in running_state) and (lower >= 0) and (upper <= len(running_state[args[0]]))):
                    running_state[args[0]] = running_state[args[0]][lower:upper]
                    return running_state[args[0]]
                else:
                    return 'fail'
        elif (type == 'append'):
            if (len(args) > 1):
                if (args[0] in running_state):
                    running_state[args[0]] = (running_state[args[0]] + args[1])
                    return 'OK'
                else:
                    return 'fail'

    def send_request(self, type, args, retry):
        args = self._state.private_key.sign(str(args).encode('utf-8'))
        if retry:
            self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args), to=self._state.replicas)
        else:
            self._state.request_id += 1
            self.send((None, 'Request', type, self._id, self._id, self._state.request_id, self._state.client_id, args), to=self._state.head)

    def validate_result(self, result, result_proof):
        if (len(result_proof) < (self._state.num_failures + 1)):
            self.output_wrapper('Number of result proofs received are less than the majority (failures + 1).')
            return (False, True)
        majority = 0
        hash = self.calculate_hash(result)
        for i in result_proof:
            if (hash == i[1]):
                majority += 1
        self.output_wrapper('Number of correct result proofs received :{}, required majority: {}'.format(majority, (self._state.num_failures + 1)))
        if (majority < (self._state.num_failures + 1)):
            return (False, True)
        elif (majority < ((2 * self._state.num_failures) + 1)):
            return (True, True)
        return (True, False)

    def calculate_hash(self, val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        return sha256(val, encoder=HexEncoder)

    def output_wrapper(self, log):
        self.output('[{}][TS: {}]'.format(self._state.name, str(time())), log)

    def _Client_handler_2548(self, replicas_, head_, olympus):
        self._state.replicas = replicas_
        self._state.head = head_
        self.output_wrapper((self._state.name + ' is configured.'))
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_2548._labels = None
    _Client_handler_2548._notlabels = None

    def _Client_handler_2580(self, replica_public_keys_, olympus_public_key_, olympus):
        self._state.replica_public_keys = [VerifyKey(key, encoder=HexEncoder) for key in replica_public_keys_]
        self._state.olympus_public_key = VerifyKey(olympus_public_key_, encoder=HexEncoder)
        self.output_wrapper('Received the public keys of replicas from Olympus')
        self.output_wrapper('Received the public key of Olympus.')
        self.send(('ACK', self._state.name), to=olympus)
    _Client_handler_2580._labels = None
    _Client_handler_2580._notlabels = None

    def _Client_handler_2625(self, sender_id, request_id, result_shuttle):
        result_shuttle = self.verify_data_with_key(result_shuttle, self._state.replica_public_keys[sender_id])
        if (result_shuttle == None):
            self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed.'))
            return
        (result, result_proof) = result_shuttle
        (is_result__valid, is_reconfiguration_required) = self.validate_result(result, result_proof)
        if is_result__valid:
            if ((not (result == 'fail')) or (not (result == ''))):
                self.update_client_running_state(self._state.client_running_state_sync, result_proof[0][0][0], result_proof[0][0][1])
            self.output_wrapper('Valid result: {} received for request id: {}'.format(str(result), str(request_id)))
        if is_reconfiguration_required:
            self.output_wrapper('Misbehaviour detected in request id: {}! Sending reconfiguration request to Olympus'.format(request_id))
            self.send(('Reconfiguration', self._state.name, result_shuttle), to=self._state.olympus)
    _Client_handler_2625._labels = None
    _Client_handler_2625._notlabels = None

def parse_program_args(argv):
    inputfile = ''
    output_wrapperfile = ''
    try:
        (opts, args) = getopt.getopt(argv, 'hi:o:', ['ifile=', 'ofile='])
    except getopt.GetoptError:
        output_wrapper('Error in parsing arguments')
        return None
    for (opt, arg) in opts:
        if (opt in ('-i', '--ifile')):
            inputfile = arg
        elif (opt in ('-o', '--ofile')):
            output_wrapperfile = arg
    return [inputfile, output_wrapperfile]

def are_dicts_equal(d1, d2):
    return ((len(d1) == len(d2)) and all(((k in d2) for k in d1)))

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):

        def output_wrapper(log):
            self.output('[Main][TS: {}]'.format(str(time())), log)
        if (len(sys.argv) < 2):
            output_wrapper('Incorrect argument count. Must specify the input configuration file atleast')
            return
        [infile, outfile] = parse_program_args(sys.argv[1:])
        if (infile == None):
            output_wrapper('Must specify input configuration file!')
            sys.exit(2)
        config_dict = read_config.parse_config_file(infile)
        global_config = GlobalConfig(config_dict)
        client_config = ClientConfig(config_dict)
        replica_config = ReplicaConfig(config_dict)
        output_wrapper(('Running BCR simulation for test case: ' + global_config.test_case_name))
        olympus = self.new(Olympus, args=('Olympus', replica_config.num_replica, replica_config.failures, replica_config.head_timeout, replica_config.nonhead_timeout))
        self._start(olympus)
        clients = list()
        for i in range(client_config.num_client):
            request_id_counter = (i * 10000)
            modified_ops = list(map((lambda o: (o.type.name, o.args_list)), client_config.workloads[i]))
            output_wrapper('Workload for client {} : {}'.format(str(i), str(modified_ops)))
            client = self.new(Client, args=(i, olympus, (request_id_counter - 1), client_config.client_timeout, modified_ops, client_config.num_failures))
            clients.append(client)
        self._start(clients)
