import uuid
import nacl

class Client(process):
    # client state variables
    Olympus
    T = T                    # Max number of tolerated failures in system
    timeout = x seconds     # client's timeout for queries
    replicas = []            # replica IDs in the current configuration
    replica_public_keys = {} # mapping of replica ID vs its public key

    Client(self, Olympus, T, timeout, replicas, replica_public_keys):
        self.Olympus = Olympus
        self.T = T
        self.timeout = timeout
        self.replicas = replicas
        self.replica_public_keys = replica_public_keys


    # client methods
    def request_configuration():
        send ('get_configuration', to= olympus)
        wait(on_message_received('configuration'), timeout)


    def receive(msg=('configuration', replicas, replica_public_keys)):
        replicas = replicas
        replica_public_keys = replica_public_keys
        output("Client received new configuration");


    def generate_request_id():
        return uuid.uuid4().__str__()

    def execute_operation(o):
        # o is the operation that the client wants to execute
        request_configuration()
        # olympus has sent back latest configuration
        request_id = generate_request_id()
        head = replicas[0]
        send('request', o, request_id, to= head)
        if await(received('result', result, result_proofs, o)):
                    --end
                    output("Received result %s for operation_id" % (result, request_id))
        elif timeout(timeout):
            output("Failed to receive result for operation %s in time, retrying.", retr)
        handle_request_retry(request_id, o)

    def received(msg=('result', result, result_proofs, o)):
        # On receiving a result, check if the result hash is correct for atleast (T + 1) replicas so that atleast one is honest
        # Assumption: result_proofs from each replica r' are in the same order as replicas
        verified_count = 0
        for i from 1 to size(replicas):
            if verify_signature(<o, hash(result)>, result_proofs[i], replica_public_keys[i]) == true:
                verified_count += 1

        if verified_count >= T + 1:
            log('Operation successful', o)
        else
            log('Operation failure', o)
            send('request_reconfiguration_client', result, result_proofs, o) to Olympus
        # client operation successful
        exit

    def received(msg=('retry_error', o)) {
        # This means that re-configuration is taking place in the system. Retry again after a while.
        if (await (0)):
            #don't do anything

        elif timeout(timeout):
            execute_operation(o)
    }


    def handle_request_retry(request_id, o):
        # now we will retry our request by sending to all replicas in the chain, not just the head
        # After sending our requests, we wait till we get atleast one response
        for i from 1 to size(replicas):
            send(('request', o, request_id), to= replica[i])
        await(('response',


    def verify_signature(message, signature, key):
        verify_key = nacl.signing.VerifyKey(verify_key_hex, encoder=nacl.encoding.HexEncoder)
        return verify(message, signature, encoder=nacl.encoding.HexEncoder)


