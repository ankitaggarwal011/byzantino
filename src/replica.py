# -*- generated by 1.0.11 -*-
import da
PatternExpr_460 = da.pat.ConstantPattern('Shutdown')
PatternExpr_464 = da.pat.BoundPattern('_BoundPattern465_')
PatternExpr_478 = da.pat.ConstantPattern('Shutdown')
PatternExpr_482 = da.pat.FreePattern('olympus')
PatternExpr_499 = da.pat.TuplePattern([da.pat.ConstantPattern('Configuration'), da.pat.FreePattern('olympus_'), da.pat.FreePattern('replicas_'), da.pat.FreePattern('head_'), da.pat.FreePattern('tail_'), da.pat.FreePattern('config_data')])
PatternExpr_698 = da.pat.TuplePattern([da.pat.ConstantPattern('Key'), da.pat.FreePattern('private_key_')])
PatternExpr_705 = da.pat.FreePattern('olympus')
PatternExpr_725 = da.pat.TuplePattern([da.pat.ConstantPattern('Client_keys'), da.pat.FreePattern('client_id'), da.pat.FreePattern('client_public_key')])
PatternExpr_763 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Request'), da.pat.FreePattern('type'), da.pat.FreePattern('request_from'), da.pat.FreePattern('client'), da.pat.FreePattern('request_id'), da.pat.FreePattern('client_id'), da.pat.FreePattern('client_args'), da.pat.FreePattern('args')])
PatternExpr_1167 = da.pat.BoundPattern('_BoundPattern1173_')
PatternExpr_1689 = da.pat.BoundPattern('_BoundPattern1695_')
PatternExpr_2349 = da.pat.BoundPattern('_BoundPattern2355_')
PatternExpr_2473 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Checkpoint_proof'), da.pat.FreePattern('args')])
PatternExpr_2884 = da.pat.TuplePattern([da.pat.FreePattern('sender_id'), da.pat.ConstantPattern('Result_shuttle'), da.pat.FreePattern('request_from'), da.pat.FreePattern('request_id'), da.pat.FreePattern('client_id'), da.pat.FreePattern('result_shuttle')])
PatternExpr_3263 = da.pat.ConstantPattern('wedge_request')
PatternExpr_3267 = da.pat.FreePattern('olympus')
PatternExpr_3484 = da.pat.TuplePattern([da.pat.ConstantPattern('catch_up'), da.pat.FreePattern('gap')])
PatternExpr_3491 = da.pat.FreePattern('olympus')
PatternExpr_3683 = da.pat.ConstantPattern('get_running_state')
PatternExpr_3687 = da.pat.FreePattern('olympus')
PatternExpr_3835 = da.pat.TuplePattern([da.pat.ConstantPattern('get_running_state'), da.pat.FreePattern('client'), da.pat.FreePattern('requests_')])
PatternExpr_466 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern472_')]), da.pat.ConstantPattern('Shutdown')])
PatternExpr_1175 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern1182_')])
PatternExpr_1697 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern1704_')])
PatternExpr_2357 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.BoundPattern('_BoundPattern2364_')])
_config_object = {'channel': {'reliable', 'fifo'}}
from logging import shutdown
from os import _exit
from copy import deepcopy
from nacl.hash import sha256
from nacl.encoding import HexEncoder
from nacl.signing import SigningKey, VerifyKey, SignedMessage
from nacl.exceptions import BadSignatureError
from pickle import dumps, loads
from json import dumps as dump_to
from time import time, sleep
from config import *
import read_config

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_0 = []
        self._ReplicaReceivedEvent_6 = []
        self._ReplicaReceivedEvent_7 = []
        self._ReplicaReceivedEvent_8 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_460, sources=[PatternExpr_464], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_478, sources=[PatternExpr_482], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_477]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_499, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_498]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_698, sources=[PatternExpr_705], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_697]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_725, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_724]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_763, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_762]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_1167, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_1689, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_2349, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_2473, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2472]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_10', PatternExpr_2884, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2883]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_11', PatternExpr_3263, sources=[PatternExpr_3267], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3262]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_12', PatternExpr_3484, sources=[PatternExpr_3491], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3483]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_13', PatternExpr_3683, sources=[PatternExpr_3687], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3682]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_14', PatternExpr_3835, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3834])])

    def setup(self, id, name, running_state, replica_failures, replica_timeout, olympus_public_key, checkpt_interval, slot_number, **rest_4690):
        super().setup(id=id, name=name, running_state=running_state, replica_failures=replica_failures, replica_timeout=replica_timeout, olympus_public_key=olympus_public_key, checkpt_interval=checkpt_interval, slot_number=slot_number, **rest_4690)
        self._state.id = id
        self._state.name = name
        self._state.running_state = running_state
        self._state.replica_failures = replica_failures
        self._state.replica_timeout = replica_timeout
        self._state.olympus_public_key = olympus_public_key
        self._state.checkpt_interval = checkpt_interval
        self._state.slot_number = slot_number
        self.output_wrapper(('Replica failures: ' + str(self._state.replica_failures)))
        self._state.status = 0
        self._state.order_proof = list()
        self._state.result_proof = list()
        self._state.result_cache = dict()
        self._state.checkpoint = 0
        self._state.checkpt_proof_state = None
        self._state.last_slot_number = self._state.slot_number
        self._state.olympus = None
        self._state.replicas = None
        self._state.head = None
        self._state.tail = None
        self._state.replica_public_keys = None
        self._state.private_key = None
        self._state.client_keys = dict()
        self._state.configuration = None
        self._state.pending_failures = {}
        self._state.pending_failure_scenarios = {}
        self._state.messages_received_from_client = {}
        self._state.messages_shuttle = {}
        self._state.messages_result_shuttle = {}
        self._state.messages_forwarded_request = {}
        self._state.ongoing_request_id = None
        self._state.history = list()
        self._state.most_recent_result = dict()
        self._state.request_to_client = dict()
        self._state.wedge_requests_received = 0
        self._state.get_running_state_messages = 0
        self._state.catch_up_messages = 0
        self._state.checkpt_messages = 0
        self._state.checkpt_proof_messages = 0
        self._state.new_configuration_messages = 0

    def run(self):
        self._state.status = 1
        self._state.olympus_public_key = VerifyKey(self._state.olympus_public_key, encoder=HexEncoder)
        self.output_wrapper(((('A new replica (' + str(self._state.name)) + ')') + ' is created.'))
        super()._label('_st_label_457', block=False)
        _st_label_457 = 0
        while (_st_label_457 == 0):
            _st_label_457 += 1
            if PatternExpr_466.match_iter(self._ReplicaReceivedEvent_0, _BoundPattern472_=self._state.olympus, SELF_ID=self._id):
                _st_label_457 += 1
            else:
                super()._label('_st_label_457', block=True)
                _st_label_457 -= 1

    def is_tail(self):
        return ((isinstance(self._state.tail, set) and (self._id in self._state.tail)) or ((not isinstance(self._state.tail, set)) and (self._id == self._state.tail)))

    def is_head(self):
        return ((isinstance(self._state.head, set) and (self._id in self._state.head)) or ((not isinstance(self._state.head, set)) and (self._id == self._state.head)))

    def is_client(self, request_from, client):
        return ((isinstance(request_from, set) and (client in request_from)) or ((not isinstance(request_from, set)) and (request_from == client)))

    def validate_checkpoint(self, checkpt_p):
        if (len(checkpt_p) == 0):
            return False
        checkpt = checkpt_p[0]
        if ((not (checkpt_p.count(checkpt) == len(checkpt_p))) or (checkpt[0] <= self._state.checkpoint)):
            return False
        return True

    def validate_checkpoint_proof(self, checkpt_p):
        if ((len(checkpt_p) == 0) or (not (len(checkpt_p) == len(self._state.replicas)))):
            return False
        checkpt = checkpt_p[0]
        if ((not (checkpt_p.count(checkpt) == len(checkpt_p))) or (checkpt[0] <= self._state.checkpoint)):
            return False
        return True

    def update_running_state(self, type, args):
        if (type == 'put'):
            if (len(args) > 1):
                self._state.running_state[args[0]] = args[1]
            return 'OK'
        elif (type == 'get'):
            if (len(args) > 0):
                if (args[0] in self._state.running_state):
                    return self._state.running_state[args[0]]
                else:
                    return ''
        elif (type == 'slice'):
            if (len(args) > 1):
                (lower, upper) = map(int, args[1].split(':'))
                if ((args[0] in self._state.running_state) and (lower >= 0) and (upper <= len(self._state.running_state[args[0]]))):
                    self._state.running_state[args[0]] = self._state.running_state[args[0]][lower:upper]
                    return self._state.running_state[args[0]]
                else:
                    return 'fail'
        elif (type == 'append'):
            if (len(args) > 1):
                if (args[0] in self._state.running_state):
                    self._state.running_state[args[0]] = (self._state.running_state[args[0]] + args[1])
                    return 'OK'
                else:
                    return 'fail'

    def calculate_hash(self, val):
        if isinstance(val, str):
            return sha256(str.encode(val), encoder=HexEncoder)
        return sha256(str.encode(dump_to(val, sort_keys=True)), encoder=HexEncoder)

    def validate_shuttle(self, shuttle):
        (self._state.order_proof, self._state.result_proof) = shuttle
        (self._state.slot_number, operation, self._state.configuration, order_stmt, request_id) = self._state.order_proof
        if (not (self._state.last_slot_number == (self._state.slot_number - 1))):
            self.output_wrapper((('Slot number inconsistency while validating the shuttle at ' + str(self._state.name)) + '.'))
            return False
        for stmt in order_stmt:
            if ((not (stmt[0] == self._state.slot_number)) or (not (stmt[1] == operation)) or (not (stmt[2] == self._state.configuration))):
                return False
        return True

    def validate_result_shuttle(self, result_shuttle):
        (result, self._state.result_proof) = result_shuttle
        if (not (len(self._state.result_proof) == len(self._state.replicas))):
            return False
        hash = self.calculate_hash(result)
        for i in self._state.result_proof:
            if (not (hash == i[1])):
                return False
        return True

    def sign_and_send(self, data, to_):
        data = ([self._state.id] + list(data))
        data[(- 1)] = self._state.private_key.sign(dumps(data[(- 1)]))
        self.send(tuple(data), to=to_)

    def verify_data_with_key(self, data, pub_key):
        try:
            pub_key.verify(data)
            return loads(data.message)
        except BadSignatureError:
            return None

    def check_failure(self, required_type, client_id):
        for (i, failure) in enumerate(self._state.replica_failures):
            oper = failure.operands
            if (failure.failure_type == required_type):
                if ((required_type == FailureType.client_request) and (not (client_id == None))):
                    if ((client_id == oper[0]) and (self._state.messages_received_from_client[client_id] == oper[1])):
                        return (True, failure)
                elif ((required_type == FailureType.forwarded_request) and (not (client_id == None))):
                    if ((client_id == oper[0]) and (self._state.messages_forwarded_request[client_id] == oper[1])):
                        return (True, failure)
                elif ((required_type == FailureType.shuttle) and (not (client_id == None))):
                    if ((client_id == oper[0]) and (self._state.messages_shuttle[client_id] == oper[1])):
                        return (True, failure)
                elif ((required_type == FailureType.result_shuttle) and (not (client_id == None))):
                    if ((client_id == oper[0]) and (self._state.messages_result_shuttle[client_id] == oper[1])):
                        return (True, failure)
                elif (required_type == FailureType.wedge_request):
                    if (self._state.wedge_requests_received == oper[0]):
                        return (True, failure)
                elif (required_type == FailureType.new_configuration):
                    if (self._state.new_configuration_messages == oper[0]):
                        return (True, failure)
                elif (required_type == FailureType.checkpoint):
                    if (self._state.checkpt_messages == oper[0]):
                        return (True, failure)
                elif (required_type == FailureType.completed_checkpoint):
                    if (self._state.checkpt_proof_messages == oper[0]):
                        return (True, failure)
                elif (required_type == FailureType.get_running_state):
                    if (self._state.get_running_state_messages == oper[0]):
                        return (True, failure)
                elif (required_type == FailureType.catch_up):
                    if (self._state.catch_up_messages == oper[0]):
                        return (True, failure)
        return (False, None)

    def check_all_failures(self, client_id):
        self.output_wrapper('Checking if any failure trigger conditions are satisfied.')
        failure_trigger_types = [FailureType.client_request, FailureType.forwarded_request, FailureType.shuttle, FailureType.result_shuttle, FailureType.wedge_request, FailureType.new_configuration, FailureType.checkpoint, FailureType.completed_checkpoint, FailureType.get_running_state, FailureType.catch_up]
        for each_trigger in failure_trigger_types:
            (is_trigger, scenario) = self.check_failure(each_trigger, client_id)
            if is_trigger:
                self._state.pending_failures[scenario.action_type] = 1
                self._state.pending_failure_scenarios[scenario.action_type] = scenario
                self.output_wrapper('Replica {}: Trigger {} failure for client_id: {}, and scenario: {}'.format(self._state.name, each_trigger, client_id, scenario.action_type))

    def exec_failures(self, failure_list):
        return_val = 0
        for each_failure in failure_list:
            if ((each_failure in self._state.pending_failures) and (self._state.pending_failures[each_failure] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[each_failure])))
                params = self._state.pending_failure_scenarios[each_failure].action_operands
                if (each_failure == FailureActionType.crash):
                    self.crash()
                elif (each_failure == FailureActionType.sleep):
                    self.output_wrapper((('Sleep failure: Replica going to sleep for ' + str(params[0])) + ' milliseconds.'))
                    sleep((params[0] / 1000))
                elif (each_failure == FailureActionType.drop):
                    self.output_wrapper('Drop failure: Dropping the message that triggered the failure.')
                    return_val = 1
            self._state.pending_failures[each_failure] = 0
            self._state.pending_failure_scenarios[each_failure] = None
        return return_val

    def crash(self):
        self.output_wrapper('Crash failure: Replica shutting down!')
        shutdown()
        _exit((- 1))

    def corrupt_sign_and_send(self, data, send_to):
        data = ([self._state.id] + list(data))
        data[(- 1)] = self._state.private_key.sign(dumps(data[(- 1)]))
        signed = data[(- 1)]
        signedlist = list(signed)
        signedlist[0] = ((signedlist[0] + 1) % 256)
        newsigned = bytes(signedlist)
        data[(- 1)] = SignedMessage._from_parts(signed._signature, signed._message, newsigned)
        self.send(tuple(data), to=send_to)

    def output_wrapper(self, log):
        self.output('[TS: {}][{}]'.format(str(time()), self._state.name), log)

    def _Replica_handler_477(self, olympus):
        self.output_wrapper((((self._state.name + " is now shutting down.\nIt's final running state is:\n") + str(self._state.running_state)) + '.\n'))
    _Replica_handler_477._labels = None
    _Replica_handler_477._notlabels = None

    def _Replica_handler_498(self, olympus_, replicas_, head_, tail_, config_data):
        self._state.olympus = olympus_
        self._state.replicas = replicas_
        self._state.head = head_
        self._state.tail = tail_
        config_data = self.verify_data_with_key(config_data, self._state.olympus_public_key)
        if (config_data is None):
            self.output_wrapper('Verification of message sent by Olympus has failed.')
            self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
            return
        (replica_public_keys_, self._state.configuration) = config_data
        self._state.replica_public_keys = [VerifyKey(key, encoder=HexEncoder) for key in replica_public_keys_]
        self.check_all_failures(None)
        self._state.new_configuration_messages += 1
        failure_list = [FailureActionType.crash, FailureActionType.sleep, FailureActionType.drop]
        if (self.exec_failures(failure_list) == 1):
            return
        if ((FailureActionType.extra_op in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.extra_op] == 1)):
            self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.extra_op])))
            self.update_running_state('put', ('a', 'a'))
            self.output_wrapper("extra_op failure: Applying put('a','a') to the running state.")
            self._state.pending_failures[FailureActionType.extra_op] = 0
            self._state.pending_failure_scenarios[FailureActionType.extra_op] = None
        if self.is_head():
            if ((FailureActionType.increment_slot in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.increment_slot] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.increment_slot])))
                self._state.slot_number += 1
                self.output_wrapper('increment_slot failure: Incrementing slot number at head by 1.')
                self._state.pending_failures[FailureActionType.increment_slot] = 0
                self._state.pending_failure_scenarios[FailureActionType.increment_slot] = None
        self.output_wrapper('{} received replica references and public keys from Olympus'.format(self._state.name))
        self.send(('ACK', self._state.name), to=self._state.olympus)
    _Replica_handler_498._labels = None
    _Replica_handler_498._notlabels = None

    def _Replica_handler_697(self, private_key_, olympus):
        self._state.private_key = private_key_
        self.output_wrapper((self._state.name + ' has received its private key from Olympus.'))
        self.send(('ACK', self._state.name), to=olympus)
    _Replica_handler_697._labels = None
    _Replica_handler_697._notlabels = None

    def _Replica_handler_724(self, client_id, client_public_key):
        self._state.client_keys[client_id] = VerifyKey(client_public_key, encoder=HexEncoder)
        self.output_wrapper('{} has received client public key: {} for client {}'.format(self._state.name, str(client_public_key), str(client_id)))
        self.send(('ACK', self._state.name), to=self._state.olympus)
    _Replica_handler_724._labels = None
    _Replica_handler_724._notlabels = None

    def _Replica_handler_762(self, sender_id, type, request_from, client, request_id, client_id, client_args, args):
        if self.is_client(request_from, client):
            self.output_wrapper((((((((str(type) + ' request with request id ') + str(request_id)) + ' from ') + str(request_from)) + ' is received by ') + str(self._state.name)) + '.'))
        self._state.request_to_client[request_id] = client_id
        if (self._state.status == 0):
            self.output_wrapper((self._state.name + ' is in PENDING state.'))
        elif (self._state.status == 1):
            self.output_wrapper((self._state.name + ' is in ACTIVE state.'))
        elif (self._state.status == 2):
            self.output_wrapper((self._state.name + ' is in IMMUTABLE state.'))
        if (not (self._state.status == 1)):
            if ((request_from == client) and (self._state.status == 2)):
                self.output_wrapper('Sending ERROR message to the client.')
                self.send((self._state.id, 'Operation_result_error', request_id), to=client)
            return
        if (not (client_id in self._state.messages_received_from_client)):
            self._state.messages_received_from_client[client_id] = 0
        if (not (client_id in self._state.messages_forwarded_request)):
            self._state.messages_forwarded_request[client_id] = 0
        if (not (client_id in self._state.messages_shuttle)):
            self._state.messages_shuttle[client_id] = 0
        if (not (client_id in self._state.messages_result_shuttle)):
            self._state.messages_result_shuttle[client_id] = 0
        self.check_all_failures(client_id)
        failure_list = [FailureActionType.crash, FailureActionType.sleep, FailureActionType.drop]
        if (self.exec_failures(failure_list) == 1):
            return
        if ((FailureActionType.extra_op in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.extra_op] == 1)):
            self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.extra_op])))
            self.update_running_state('put', ('a', 'a'))
            self.output_wrapper("extra_op failure: Applying put('a','a') to the running state.")
            self._state.pending_failures[FailureActionType.extra_op] = 0
            self._state.pending_failure_scenarios[FailureActionType.extra_op] = None
        if self.is_head():
            if ((FailureActionType.increment_slot in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.increment_slot] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.increment_slot])))
                self._state.slot_number += 1
                self.output_wrapper('increment_slot failure: Incrementing slot number at head by 1.')
                self._state.pending_failures[FailureActionType.increment_slot] = 0
                self._state.pending_failure_scenarios[FailureActionType.increment_slot] = None
            if (self._state.ongoing_request_id == request_id):
                self.output_wrapper((((('Request id ' + str(request_id)) + ' of Client ') + str(client_id)) + ' is already running.'))
                return
            self._state.ongoing_request_id = request_id
        if (request_from == client):
            self._state.messages_received_from_client[client_id] += 1
            args = self.verify_data_with_key(client_args, self._state.client_keys[client_id])
            if (args == None):
                self.output_wrapper((('Verification of message sent by Client ' + str(client_id)) + ' has failed.'))
                self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                return
            if (request_id in self._state.result_cache):
                self.sign_and_send(('Operation_result', self._state.result_cache[(client_id, request_id)]), client)
                self.send(('Operation_result_' + str(request_id)), to=client)
                self.output_wrapper((((((('Result sent to Client ' + str(client_id)) + ' for request id ') + str(request_id)) + ' from the cache of ') + self._state.name) + '.'))
                return
            elif (not self.is_head()):
                self.output_wrapper((('Forwarding the request received from Client ' + str(client_id)) + ' to HEAD.'))
                self.sign_and_send(('Request', type, self._id, client, request_id, client_id, client_args, client_args), self._state.head)
                super()._label('_st_label_1164', block=False)
                _st_label_1164 = 0
                self._timer_start()
                while (_st_label_1164 == 0):
                    _st_label_1164 += 1
                    if PatternExpr_1175.match_iter(self._ReplicaReceivedEvent_6, _BoundPattern1182_=('Result_shuttle_' + str(request_id)), SELF_ID=self._id):
                        self.output_wrapper(((('Head-forwarded result shuttle is received at ' + str(self._state.name)) + ' for request id ') + str(request_id)))
                        _st_label_1164 += 1
                    elif self._timer_expired:
                        self.output_wrapper((((((str(self._state.name) + ' has timed out waiting for the result shuttle of head-forwarded request id ') + str(request_id)) + ' from Client ') + str(client_id)) + '. Sending reconfiguration request.'))
                        self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                        _st_label_1164 += 1
                    else:
                        super()._label('_st_label_1164', block=True, timeout=self._state.replica_timeout)
                        _st_label_1164 -= 1
                return
        else:
            _client_args = self.verify_data_with_key(client_args, self._state.client_keys[client_id])
            if (_client_args == None):
                self.output_wrapper((('Verification of client message forwarded by head and sent by Client ' + str(client_id)) + ' has failed.'))
                self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                return
            args = self.verify_data_with_key(args, self._state.replica_public_keys[sender_id])
            if (args == None):
                self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed.'))
                self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                return
            if (not (_client_args == args[0][1][1])):
                self.output_wrapper((('Verification of operations forwarded by head and sent by Client ' + str(client_id)) + ' has failed. Head might be faulty.'))
                self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                return
            self.output_wrapper("Client request (with client's signature) forwarded by the head is validated. Head is not faulty.")
        if self.is_head():
            if (not self.is_client(request_from, client)):
                self._state.messages_forwarded_request[client_id] += 1
            self._state.slot_number += 1
            self.output_wrapper((((((('Request with id ' + str(request_id)) + ' from client ') + str(client_id)) + ' has been assigned to the slot number ') + str(self._state.slot_number)) + '.'))
            result = self.update_running_state(type, args)
            if ((self._state.slot_number > 0) and ((self._state.slot_number % self._state.checkpt_interval) == 0)):
                self.output_wrapper((('Initiating checkpoint shuttle for slot number: ' + str(self._state.slot_number)) + '.'))
                checkpt_proof = [[self._state.slot_number, self.calculate_hash(self._state.running_state)]]
            else:
                checkpt_proof = None
            res_stmt = [(type, args), self.calculate_hash(result)]
            self._state.most_recent_result[client_id] = [result, res_stmt, request_id]
            if ((FailureActionType.change_operation in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.change_operation] == 1)):
                stmt_type = 'get'
                stmt_args = ['x']
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.change_operation])))
                self.output_wrapper("change_operation failure: replica uses get('x') as the operation in its order statement and result statement in the next outgoing shuttle message.")
                self._state.pending_failures[FailureActionType.change_operation] = 0
                self._state.pending_failure_scenarios[FailureActionType.change_operation] = None
            else:
                stmt_type = type
                stmt_args = args
            order_stmt = [[self._state.slot_number, (stmt_type, stmt_args), self._state.configuration]]
            self._state.order_proof = [self._state.slot_number, (type, args), self._state.configuration, order_stmt, request_id]
            self._state.result_proof = [[(type, args), self.calculate_hash(result)]]
            shuttle = (self._state.order_proof, self._state.result_proof, checkpt_proof)
            self._state.history.append(deepcopy(self._state.order_proof))
            self.output_wrapper((((((((('Shuttle with slot number ' + str(self._state.slot_number)) + ' for request id ') + str(request_id)) + ' and Client ') + str(client_id)) + ' is sent from ') + str(self._state.name)) + ' to next replica.'))
            (corrupt_order, corrupt_result) = (0, 0)
            if ((FailureActionType.invalid_order_sig in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.invalid_order_sig] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.invalid_order_sig])))
                self.output_wrapper('invalid_order_sig failure: Changed the signature of next outgoing order stmt in the shuttle to an invalid signature.')
                corrupt_order = 1
                self._state.pending_failures[FailureActionType.invalid_order_sig] = 0
                self._state.pending_failure_scenarios[FailureActionType.invalid_order_sig] = None
            elif ((FailureActionType.invalid_result_sig in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.invalid_result_sig] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.invalid_result_sig])))
                self.output_wrapper('invalid_result_sig failure: Changed the signature of next outgoing result stmt in the shuttle to an invalid signature.')
                corrupt_result = 1
                self._state.pending_failures[FailureActionType.invalid_result_sig] = 0
                self._state.pending_failure_scenarios[FailureActionType.invalid_result_sig] = None
            if (corrupt_order or corrupt_result):
                self.corrupt_sign_and_send(('Request', type, self._id, client, request_id, client_id, client_args, shuttle), self._state.replicas.get((self._state.id + 1)))
            else:
                self.sign_and_send(('Request', type, self._id, client, request_id, client_id, client_args, shuttle), self._state.replicas.get((self._state.id + 1)))
            self._state.last_slot_number = self._state.slot_number
            super()._label('_st_label_1686', block=False)
            _st_label_1686 = 0
            self._timer_start()
            while (_st_label_1686 == 0):
                _st_label_1686 += 1
                if PatternExpr_1697.match_iter(self._ReplicaReceivedEvent_7, _BoundPattern1704_=('Result_shuttle_' + str(request_id)), SELF_ID=self._id):
                    self._state.ongoing_request_id = None
                    _st_label_1686 += 1
                elif self._timer_expired:
                    self.output_wrapper('{} has timed out while waiting for result shuttle for request id {} and slot number {}. Sending reconfiguration request to Olympus'.format(self._state.name, str(request_id), str(self._state.slot_number)))
                    self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                    return
                    _st_label_1686 += 1
                else:
                    super()._label('_st_label_1686', block=True, timeout=self._state.replica_timeout)
                    _st_label_1686 -= 1
        else:
            self._state.messages_shuttle[client_id] += 1
            if (not self.validate_shuttle(args[:(- 1)])):
                self.output_wrapper('{} failed to validate shuttle for request_id: {}. Triggering reconfiguration'.format(self._state.name, str(request_id)))
                self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                return
            (self._state.order_proof, self._state.result_proof, checkpt_proof) = args
            (self._state.slot_number, operation, self._state.configuration, order_stmt, request_id) = self._state.order_proof
            (type, operation_args) = operation
            result = self.update_running_state(type, operation_args)
            if ((not (checkpt_proof == None)) and (self._state.slot_number > 0) and ((self._state.slot_number % self._state.checkpt_interval) == 0)):
                self._state.checkpt_messages += 1
                if self.validate_checkpoint(checkpt_proof):
                    checkpt_proof.append([self._state.slot_number, self.calculate_hash(self._state.running_state)])
                else:
                    self.output_wrapper((((('Checkpoint validation for slot number ' + str(self._state.slot_number)) + ' has failed at ') + str(self._state.name)) + '. Sending reconfiguration request.'))
                    self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                    return
            res_stmt = [(type, operation_args), self.calculate_hash(result)]
            self._state.most_recent_result[client_id] = [result, res_stmt, request_id]
            if ((FailureActionType.change_operation in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.change_operation] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.change_operation])))
                type = 'get'
                operation_args = ['x']
                self._state.pending_failures[FailureActionType.change_operation] = 0
                self._state.pending_failure_scenarios[FailureActionType.change_operation] = None
            self._state.order_proof[3].append([self._state.slot_number, (type, operation_args), self._state.configuration])
            self._state.result_proof.append([(type, operation_args), self.calculate_hash(result)])
            shuttle = (self._state.order_proof, self._state.result_proof, checkpt_proof)
            self._state.history.append(deepcopy(self._state.order_proof))
            if self.is_tail():
                result_shuttle = [result, self._state.result_proof]
                if ((FailureActionType.change_result in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.change_result] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.change_result])))
                    self.output_wrapper("change_result failure: replica uses the hash of 'OK' in the next outgoing result message to a client.")
                    op_t = result_shuttle[1][self._state.id][0]
                    result_shuttle[1][self._state.id] = [op_t, self.calculate_hash('OK')]
                if ((FailureActionType.drop_result_stmt in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.drop_result_stmt] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.drop_result_stmt])))
                    self.output_wrapper("drop_result_stmt failure: omit the head's result statement from the result proof in the next outgoing result message to a client.")
                    result_t = result_shuttle[0]
                    result_shuttle = [result_t, result_shuttle[1][1:]]
                if ((FailureActionType.invalid_result_sig in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.invalid_result_sig] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.invalid_result_sig])))
                    self.output_wrapper('invalid_result_sig failure: Changed the signature of result sent to the client to an invalid signature.')
                    self.corrupt_sign_and_send(('Operation_result', request_id, result_shuttle), client)
                    self._state.pending_failures[FailureActionType.invalid_result_sig] = 0
                    self._state.pending_failure_scenarios[FailureActionType.invalid_result_sig] = None
                else:
                    self.sign_and_send(('Operation_result', request_id, result_shuttle), client)
                self.send(('Operation_result_' + str(request_id)), to=client)
                self.sign_and_send(('Result_shuttle', self._id, request_id, client_id, result_shuttle), self._state.tail)
                self.send(('Result_shuttle_' + str(request_id)), to=self._state.tail)
                if ((not (checkpt_proof == None)) and (self._state.slot_number > 0) and ((self._state.slot_number % self._state.checkpt_interval) == 0)):
                    self.sign_and_send(('Checkpoint_proof', checkpt_proof), self._id)
                self._state.last_slot_number = self._state.slot_number
            else:
                self.output_wrapper((((((((('Shuttle with slot number ' + str(self._state.slot_number)) + ' for request id ') + str(request_id)) + ' and Client ') + str(client_id)) + ' is sent from ') + str(self._state.name)) + ' to next replica.'))
                if ((not (checkpt_proof == None)) and (self._state.slot_number > 0) and ((self._state.slot_number % self._state.checkpt_interval) == 0)):
                    self.output_wrapper((((('Checkpoint shuttle for slot number: ' + str(self._state.slot_number)) + ' is at ') + str(self._state.name)) + '. Forwarding it to next Replica.'))
                (corrupt_order, corrupt_result) = (0, 0)
                if ((FailureActionType.invalid_order_sig in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.invalid_order_sig] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.invalid_order_sig])))
                    self.output_wrapper('invalid_order_sig failure: Changed the signature of next outgoing order stmt in the shuttle to an invalid signature.')
                    corrupt_order = 1
                    self._state.pending_failures[FailureActionType.invalid_order_sig] = 0
                    self._state.pending_failure_scenarios[FailureActionType.invalid_order_sig] = None
                elif ((FailureActionType.invalid_result_sig in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.invalid_result_sig] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.invalid_result_sig])))
                    self.output_wrapper('invalid_result_sig failure: Changed the signature of next outgoing result stmt in the shuttle to an invalid signature.')
                    corrupt_result = 1
                    self._state.pending_failures[FailureActionType.invalid_result_sig] = 0
                    self._state.pending_failure_scenarios[FailureActionType.invalid_result_sig] = None
                if (corrupt_order or corrupt_result):
                    self.corrupt_sign_and_send(('Request', type, self._id, client, request_id, client_id, client_args, shuttle), self._state.replicas.get((self._state.id + 1)))
                else:
                    self.sign_and_send(('Request', type, self._id, client, request_id, client_id, client_args, shuttle), self._state.replicas.get((self._state.id + 1)))
                self._state.last_slot_number = self._state.slot_number
                super()._label('_st_label_2346', block=False)
                _st_label_2346 = 0
                self._timer_start()
                while (_st_label_2346 == 0):
                    _st_label_2346 += 1
                    if PatternExpr_2357.match_iter(self._ReplicaReceivedEvent_8, _BoundPattern2364_=('Result_shuttle_' + str(request_id)), SELF_ID=self._id):
                        pass
                        _st_label_2346 += 1
                    elif self._timer_expired:
                        self.output_wrapper((((((((str(self._state.name) + ' has timed out waiting for the result shuttle of request id ') + str(request_id)) + ' and slot number ') + str(self._state.slot_number)) + ' from Client ') + str(client_id)) + '. Sending reconfiguration request.'))
                        self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
                        return
                        _st_label_2346 += 1
                    else:
                        super()._label('_st_label_2346', block=True, timeout=self._state.replica_timeout)
                        _st_label_2346 -= 1
    _Replica_handler_762._labels = None
    _Replica_handler_762._notlabels = None

    def _Replica_handler_2472(self, sender_id, args):
        self.check_all_failures(None)
        failure_list = [FailureActionType.crash, FailureActionType.sleep, FailureActionType.drop]
        if (self.exec_failures(failure_list) == 1):
            return
        if ((FailureActionType.extra_op in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.extra_op] == 1)):
            self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.extra_op])))
            self.update_running_state('put', ('a', 'a'))
            self.output_wrapper("extra_op failure: Applying put('a','a') to the running state.")
            self._state.pending_failures[FailureActionType.extra_op] = 0
            self._state.pending_failure_scenarios[FailureActionType.extra_op] = None
        if self.is_head():
            if ((FailureActionType.increment_slot in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.increment_slot] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.increment_slot])))
                self._state.slot_number += 1
                self.output_wrapper('increment_slot failure: Incrementing slot number at head by 1.')
                self._state.pending_failures[FailureActionType.increment_slot] = 0
                self._state.pending_failure_scenarios[FailureActionType.increment_slot] = None
        if (not self.is_tail()):
            self._state.checkpt_proof_messages += 1
        args = self.verify_data_with_key(args, self._state.replica_public_keys[sender_id])
        if (args == None):
            self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed during checkpoint proof back the chain.'))
            self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
            return
        s_n = args[0][0]
        if (not self.validate_checkpoint_proof(args)):
            self.output_wrapper((((('Checkpoint proof validation for slot number ' + str(s_n)) + ' back the chain has failed at ') + str(self._state.name)) + '. Sending reconfiguration request.'))
            self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
            return
        self._state.checkpt_proof_state = args
        self._state.checkpoint = s_n
        self._state.history = self._state.history[self._state.checkpoint:]
        self.output_wrapper((((('Truncating history at ' + str(self._state.name)) + ' to validated checkpoint proof on the slot number ') + str(self._state.checkpoint)) + '.'))
        if (not self.is_head()):
            self.output_wrapper((((('Checkpoint proof shuttle back the chain for slot number: ' + str(s_n)) + ' is at ') + str(self._state.name)) + '. Forwarding it to next Replica back the chain.'))
            if ((FailureActionType.drop_checkpt_stmts in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.drop_checkpt_stmts] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.drop_checkpt_stmts])))
                self.output_wrapper('drop_checkpt_stmts failure: Dropping checkpt stmts of first t + 1 replicas during next outgoing shuttle back the chain.')
                num_failures = ((len(self._state.replicas) - 1) // 2)
                self.sign_and_send(('Checkpoint_proof', args[(num_failures + 1):]), self._state.replicas.get((self._state.id - 1)))
                self._state.pending_failures[FailureActionType.drop_checkpt_stmts] = 0
                self._state.pending_failure_scenarios[FailureActionType.drop_checkpt_stmts] = None
            else:
                self.sign_and_send(('Checkpoint_proof', args), self._state.replicas.get((self._state.id - 1)))
        else:
            self.output_wrapper(('Checkpointing is complete at checkpoint ' + str(self._state.checkpoint)))
    _Replica_handler_2472._labels = None
    _Replica_handler_2472._notlabels = None

    def _Replica_handler_2883(self, sender_id, request_from, request_id, client_id, result_shuttle):
        self.check_all_failures(client_id)
        failure_list = [FailureActionType.crash, FailureActionType.sleep, FailureActionType.drop]
        if (self.exec_failures(failure_list) == 1):
            return
        if ((FailureActionType.extra_op in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.extra_op] == 1)):
            self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.extra_op])))
            self.update_running_state('put', ('a', 'a'))
            self.output_wrapper("extra_op failure: Applying put('a','a') to the running state.")
            self._state.pending_failures[FailureActionType.extra_op] = 0
            self._state.pending_failure_scenarios[FailureActionType.extra_op] = None
        if self.is_head():
            if ((FailureActionType.increment_slot in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.increment_slot] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.increment_slot])))
                self._state.slot_number += 1
                self.output_wrapper('increment_slot failure: Incrementing slot number at head by 1.')
                self._state.pending_failures[FailureActionType.increment_slot] = 0
                self._state.pending_failure_scenarios[FailureActionType.increment_slot] = None
        self._state.messages_result_shuttle[client_id] += 1
        result_shuttle = self.verify_data_with_key(result_shuttle, self._state.replica_public_keys[sender_id])
        if (result_shuttle == None):
            self.output_wrapper((('Verification of message sent by Replica ' + str(sender_id)) + ' has failed during result shuttle back the chain.'))
            self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
            return
        if self.validate_result_shuttle(result_shuttle):
            self._state.result_cache[(client_id, request_id)] = result_shuttle
            if (not self.is_head()):
                if ((FailureActionType.change_result in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.change_result] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.change_result])))
                    self.output_wrapper("change_result failure: replica uses the hash of 'OK' in the next outgoing result shuttle message.")
                    op_t = result_shuttle[1][self._state.id][0]
                    result_shuttle[1][self._state.id] = [op_t, self.calculate_hash('OK')]
                    self._state.pending_failures[FailureActionType.change_result] = 0
                    self._state.pending_failure_scenarios[FailureActionType.change_result] = None
                if ((FailureActionType.drop_result_stmt in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.drop_result_stmt] == 1)):
                    self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.drop_result_stmt])))
                    self.output_wrapper("drop_result_stmt failure: omit the head's result statement from the result proof in the next outgoing result shuttle message.")
                    result_t = result_shuttle[0]
                    result_shuttle = [result_t, result_shuttle[1][1:]]
                    self._state.pending_failures[FailureActionType.drop_result_stmt] = 0
                    self._state.pending_failure_scenarios[FailureActionType.drop_result_stmt] = None
                self.sign_and_send(('Result_shuttle', self._id, request_id, client_id, result_shuttle), self._state.replicas.get((self._state.id - 1)))
                self.send(('Result_shuttle_' + str(request_id)), to=self._state.replicas.get((self._state.id - 1)))
            self.output_wrapper((((((('Result shuttle for request id ' + str(request_id)) + ' of Client ') + str(client_id)) + ' is at ') + str(self._state.name)) + '.'))
        else:
            self.output_wrapper((((((('Result shuttle sent by Replica ' + str(sender_id)) + ' for request id ') + str(request_id)) + ' of Client ') + str(client_id)) + ' is not valid.'))
            self.send(('Reconfiguration', self._state.name, self._state.configuration), to=self._state.olympus)
            return
    _Replica_handler_2883._labels = None
    _Replica_handler_2883._notlabels = None

    def _Replica_handler_3262(self, olympus):
        self._state.status = 2
        self.output_wrapper((str(self._state.name) + ' is now IMMUTABLE.'))
        self.output_wrapper('Received wedge request from Olympus')
        self.check_all_failures(None)
        failure_list = [FailureActionType.crash, FailureActionType.sleep, FailureActionType.drop]
        if (self.exec_failures(failure_list) == 1):
            return
        if ((FailureActionType.extra_op in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.extra_op] == 1)):
            self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.extra_op])))
            self.update_running_state('put', ('a', 'a'))
            self.output_wrapper("extra_op failure: Applying put('a','a') to the running state.")
            self._state.pending_failures[FailureActionType.extra_op] = 0
            self._state.pending_failure_scenarios[FailureActionType.extra_op] = None
        if self.is_head():
            if ((FailureActionType.increment_slot in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.increment_slot] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.increment_slot])))
                self._state.slot_number += 1
                self.output_wrapper('increment_slot failure: Incrementing slot number at head by 1.')
                self._state.pending_failures[FailureActionType.increment_slot] = 0
                self._state.pending_failure_scenarios[FailureActionType.increment_slot] = None
        history_to_send = deepcopy(self._state.history)
        if ((FailureActionType.truncate_history in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.truncate_history] == 1)):
            self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.truncate_history])))
            self.output_wrapper((('truncate_history failure: Omitting the last ' + str()) + 'entries.'))
            params = self._state.pending_failure_scenarios[FailureActionType.truncate_history].action_operands
            history_to_send = history_to_send[:(len(history_to_send) - params[0])]
            self._state.pending_failures[FailureActionType.truncate_history] = 0
            self._state.pending_failure_scenarios[FailureActionType.truncate_history] = None
        self._state.wedge_requests_received += 1
        self.send(('wedge', history_to_send, self._state.checkpt_proof_state, self._state.checkpoint, self._state.id), to=olympus)
    _Replica_handler_3262._labels = None
    _Replica_handler_3262._notlabels = None

    def _Replica_handler_3483(self, gap, olympus):
        self.check_all_failures(None)
        failure_list = [FailureActionType.crash, FailureActionType.sleep, FailureActionType.drop]
        if (self.exec_failures(failure_list) == 1):
            return
        if ((FailureActionType.extra_op in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.extra_op] == 1)):
            self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.extra_op])))
            self.update_running_state('put', ('a', 'a'))
            self.output_wrapper("extra_op failure: Applying put('a','a') to the running state.")
            self._state.pending_failures[FailureActionType.extra_op] = 0
            self._state.pending_failure_scenarios[FailureActionType.extra_op] = None
        if self.is_head():
            if ((FailureActionType.increment_slot in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.increment_slot] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.increment_slot])))
                self._state.slot_number += 1
                self.output_wrapper('increment_slot failure: Incrementing slot number at head by 1.')
                self._state.pending_failures[FailureActionType.increment_slot] = 0
                self._state.pending_failure_scenarios[FailureActionType.increment_slot] = None
        self._state.catch_up_messages += 1
        for op_to_apply in gap:
            type = op_to_apply[1][0]
            args = op_to_apply[1][1]
            config = op_to_apply[2]
            result = self.update_running_state(type, args)
            request_id = op_to_apply[3]
            res_stmt = [(type, args), self.calculate_hash(result)]
            self._state.most_recent_result[self._state.request_to_client[request_id]] = [result, res_stmt, request_id]
        self.send(('caught_up', self.calculate_hash(self._state.running_state), self._state.id, self._state.most_recent_result), to=olympus)
    _Replica_handler_3483._labels = None
    _Replica_handler_3483._notlabels = None

    def _Replica_handler_3682(self, olympus):
        self.check_all_failures(None)
        failure_list = [FailureActionType.crash, FailureActionType.sleep, FailureActionType.drop]
        if (self.exec_failures(failure_list) == 1):
            return
        if ((FailureActionType.extra_op in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.extra_op] == 1)):
            self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.extra_op])))
            self.update_running_state('put', ('a', 'a'))
            self.output_wrapper("extra_op failure: Applying put('a','a') to the running state.")
            self._state.pending_failures[FailureActionType.extra_op] = 0
            self._state.pending_failure_scenarios[FailureActionType.extra_op] = None
        if self.is_head():
            if ((FailureActionType.increment_slot in self._state.pending_failures) and (self._state.pending_failures[FailureActionType.increment_slot] == 1)):
                self.output_wrapper('Executing failure scenario: {}'.format(str(self._state.pending_failure_scenarios[FailureActionType.increment_slot])))
                self._state.slot_number += 1
                self.output_wrapper('increment_slot failure: Incrementing slot number at head by 1.')
                self._state.pending_failures[FailureActionType.increment_slot] = 0
                self._state.pending_failure_scenarios[FailureActionType.increment_slot] = None
        self.output_wrapper((('Response to get_running_state sent to Olympus by ' + str(self._state.name)) + '.'))
        self._state.get_running_state_messages += 1
        self.send(('response_get_running_state', self._state.id, self._state.running_state), to=olympus)
        self.send(('response_get_running_state_' + str(self._state.id)), to=olympus)
    _Replica_handler_3682._labels = None
    _Replica_handler_3682._notlabels = None

    def _Replica_handler_3834(self, client, requests_):
        self.send(('running_state', self._state.running_state), to=client)
        self.send(('running_state_' + str(requests_)), to=client)
    _Replica_handler_3834._labels = None
    _Replica_handler_3834._notlabels = None
